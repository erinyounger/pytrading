# xTrading量化交易系统 - 软件设计文档

**版本：** v2.0.0
**日期：** 2026-01-19
**编写人：** Claude Code
**审核人：** 待定

---

## 目录

- [1. 项目概述](#1-项目概述)
- [2. 业务需求分析](#2-业务需求分析)
- [3. 系统架构设计](#3-系统架构设计)
- [4. 技术架构设计](#4-技术架构设计)
- [5. 前端UI/UX设计](#5-前端uiux设计)
- [6. 性能优化策略](#6-性能优化策略)
- [7. 安全设计](#7-安全设计)
- [8. 数据架构](#8-数据架构)
- [9. 部署架构](#9-部署架构)
- [10. 技术选型对比](#10-技术选型对比)

---

## 1. 项目概述

### 1.1 项目背景

xTrading是一个基于Python的现代化量化交易系统，支持桌面端（Tauri）、Web端（React）和移动端（React Native）多平台部署。系统提供完整的策略开发、回测和实盘交易解决方案，采用微服务架构设计，确保高性能、高可用性和易扩展性。

### 1.2 核心特性

- **多平台支持**：桌面应用、Web应用、移动应用
- **策略引擎**：模块化策略设计，支持MACD、布林带、海龟等多种经典策略
- **回测系统**：完整的回测框架，支持单股票和指数成分股回测
- **实时监控**：实时交易信号监控和风险管理
- **可视化分析**：专业的图表和数据可视化
- **云原生**：支持容器化部署和微服务架构

### 1.3 技术栈

**后端：**
- **核心框架**：Python 3.9+, FastAPI
- **量化交易**：GMI量化交易平台
- **数据存储**：MySQL 8.0, Redis缓存
- **任务队列**：Celery + Redis
- **数据处理**：Pandas, NumPy, TALib

**前端：**
- **桌面端**：Tauri (Rust + Web前端)
- **Web端**：React 18 + TypeScript
- **移动端**：React Native
- **UI框架**：TailwindCSS, Shadcn/ui
- **图表库**：Recharts, D3.js

---

## 2. 业务需求分析

### 2.1 核心用户角色

#### 2.1.1 量化研究员
- **主要需求**：
  - 策略开发和回测
  - 数据分析和研究
  - 策略性能评估
  - 批量回测支持

- **关键功能**：
  - 策略编辑器
  - 回测任务管理
  - 历史数据查询
  - 性能报告生成

#### 2.1.2 交易员
- **主要需求**：
  - 实盘交易监控
  - 交易信号接收
  - 风险管理
  - 快速决策支持

- **关键功能**：
  - 实时行情监控
  - 交易信号展示
  - 持仓管理
  - 风险预警

#### 2.1.3 投资者
- **主要需求**：
  - 投资组合查看
  - 收益分析
  - 历史表现回顾
  - 资产配置调整

- **关键功能**：
  - 资产总览
  - 收益曲线
  - 持仓分析
  - 风险指标

### 2.2 关键业务流程

#### 2.2.1 策略回测流程

```mermaid
graph TD
    A[创建回测任务] --> B[选择策略]
    B --> C[配置参数]
    C --> D[选择股票池]
    D --> E[设置时间范围]
    E --> F[启动回测]
    F --> G[后台执行]
    G --> H[实时进度更新]
    H --> I[生成结果]
    I --> J[性能分析]
    J --> K[导出报告]
```

**详细流程：**

1. **任务创建**：
   - 用户选择回测模式（单股票/指数）
   - 配置策略参数
   - 设置回测时间范围
   - 选择股票池或指数代码

2. **任务调度**：
   - 系统创建任务ID
   - 存储任务配置到数据库
   - 任务调度器轮询待执行任务
   - 分配线程池执行回测

3. **回测执行**：
   - 获取股票历史数据
   - 策略引擎逐日计算
   - 生成交易信号和订单
   - 更新回测结果

4. **结果处理**：
   - 计算性能指标（收益率、夏普比率、最大回撤等）
   - 存储结果到数据库
   - 发送任务完成通知
   - 生成可视化报告

#### 2.2.2 实盘交易流程

```mermaid
graph TD
    A[策略信号] --> B[风控检查]
    B --> C{是否通过}
    C -->|是| D[生成订单]
    C -->|否| E[拒绝交易]
    D --> F[模拟交易]
    F --> G[记录交易]
    G --> H[更新持仓]
    H --> I[发送通知]
```

#### 2.2.3 数据采集流程

```mermaid
graph LR
    A[数据源] --> B[数据清洗]
    B --> C[数据存储]
    C --> D[实时推送]
    D --> E[前端展示]
```

### 2.3 非功能性需求

#### 2.3.1 性能要求
- **响应时间**：
  - 页面加载时间 < 2秒
  - API响应时间 < 500ms
  - 回测任务启动 < 3秒
  - 大量数据查询 < 5秒

- **并发性能**：
  - 支持100+并发用户
  - 支持同时1000+回测任务
  - 支持实时数据推送10,000+连接

#### 2.3.2 可用性要求
- **系统可用性**：99.9%
- **故障恢复时间**：< 30分钟
- **数据备份**：每日自动备份
- **灾难恢复**：异地备份机制

#### 2.3.3 扩展性要求
- **水平扩展**：支持多实例部署
- **垂直扩展**：支持资源动态调整
- **模块化**：支持新策略插件式扩展
- **多租户**：支持多组织独立使用

---

## 3. 系统架构设计

### 3.1 整体架构

```mermaid
graph TB
    subgraph "客户端层"
        A1[桌面应用<br/>Tauri]
        A2[Web应用<br/>React]
        A3[移动应用<br/>React Native]
    end

    subgraph "API网关层"
        B[API网关<br/>Nginx + Kong]
    end

    subgraph "应用服务层"
        C1[用户服务]
        C2[策略服务]
        C3[回测服务]
        C4[交易服务]
        C5[数据服务]
        C6[通知服务]
    end

    subgraph "数据存储层"
        D1[MySQL主库]
        D2[MySQL从库]
        D3[Redis缓存]
        D4[时序数据库<br/>InfluxDB]
        D5[对象存储<br/>MinIO]
    end

    subgraph "消息中间件"
        E1[RabbitMQ]
        E2[WebSocket推送]
    end

    subgraph "基础设施"
        F1[Docker]
        F2[Kubernetes]
        F3[Prometheus监控]
        F4[ELK日志]
    end

    A1 --> B
    A2 --> B
    A3 --> B

    B --> C1
    B --> C2
    B --> C3
    B --> C4
    B --> C5
    B --> C6

    C1 --> D1
    C2 --> D1
    C3 --> D1
    C4 --> D1
    C5 --> D1
    C6 --> D2

    C1 --> D3
    C2 --> D3
    C3 --> D3
    C4 --> D3
    C5 --> D3
    C6 --> D3

    C3 --> D4
    C5 --> D4

    C3 --> E1
    C4 --> E1
    C6 --> E1

    C6 --> E2

    C1 --> F1
    C2 --> F1
    C3 --> F1
    C4 --> F1
    C5 --> F1
    C6 --> F1

    F1 --> F2
    F2 --> F3
    F2 --> F4
```

### 3.2 微服务划分

#### 3.2.1 用户管理服务 (User Service)
- **职责**：用户认证、授权、权限管理
- **核心功能**：
  - 用户登录/登出
  - JWT令牌管理
  - 角色权限控制
  - 用户信息管理

#### 3.2.2 策略管理服务 (Strategy Service)
- **职责**：策略生命周期管理
- **核心功能**：
  - 策略CRUD操作
  - 策略参数配置
  - 策略代码管理
  - 策略性能统计

#### 3.2.3 回测服务 (Backtest Service)
- **职责**：回测任务执行和管理
- **核心功能**：
  - 回测任务调度
  - 批量回测支持
  - 进度实时追踪
  - 结果存储和查询

#### 3.2.4 交易服务 (Trading Service)
- **职责**：模拟/实盘交易执行
- **核心功能**：
  - 交易信号处理
  - 订单生成和管理
  - 持仓管理
  - 交易记录

#### 3.2.5 数据服务 (Data Service)
- **职责**：数据采集、存储、分发
- **核心功能**：
  - 行情数据采集
  - 历史数据存储
  - 实时数据推送
  - 数据质量监控

#### 3.2.6 通知服务 (Notification Service)
- **职责**：消息推送和通知
- **核心功能**：
  - WebSocket推送
  - 邮件/短信通知
  - 系统消息管理
  - 通知模板配置

### 3.3 服务间通信

#### 3.3.1 同步通信
- **协议**：HTTP/REST API
- **使用场景**：查询类操作、配置管理
- **技术选型**：FastAPI + Pydantic

#### 3.3.2 异步通信
- **协议**：AMQP (RabbitMQ)
- **使用场景**：事件通知、任务调度
- **技术选型**：Celery + Redis

#### 3.3.3 实时通信
- **协议**：WebSocket
- **使用场景**：实时数据推送、进度更新
- **技术选型**：FastAPI WebSocket

### 3.4 数据流设计

```mermaid
graph LR
    subgraph "数据采集"
        A1[行情数据源] --> B[数据清洗]
        A2[财务数据源] --> B
        A3[新闻数据源] --> B
    end

    B --> C[数据验证]
    C --> D[(时序数据库)]
    C --> E[(MySQL)]
    C --> F[实时推送]

    D --> G[策略引擎]
    E --> G
    F --> H[前端展示]

    G --> I[交易决策]
    I --> J[订单管理]
    J --> K[交易执行]
```

---

## 4. 技术架构设计

### 4.1 Python后端架构

#### 4.1.1 整体架构

```
┌─────────────────────────────────────────────────────────┐
│                   FastAPI Web服务                        │
├─────────────────────────────────────────────────────────┤
│  API路由层                                              │
│  ├── 用户认证中间件                                      │
│  ├── 权限控制中间件                                     │
│  ├── 请求限流中间件                                     │
│  └── 日志记录中间件                                     │
├─────────────────────────────────────────────────────────┤
│  业务逻辑层                                             │
│  ├── 用户管理模块                                       │
│  ├── 策略管理模块                                       │
│  ├── 回测执行模块                                       │
│  ├── 交易执行模块                                       │
│  ├── 数据服务模块                                       │
│  └── 通知推送模块                                        │
├─────────────────────────────────────────────────────────┤
│  数据访问层 (Repository Pattern)                        │
│  ├── MySQLRepository                                   │
│  ├── RedisRepository                                   │
│  └── CacheManager                                      │
├─────────────────────────────────────────────────────────┤
│  外部依赖层                                             │
│  ├── GMI量化交易平台                                    │
│  ├── TALib技术分析库                                    │
│  ├── Pandas数据处理                                     │
│  └── NumPy数值计算                                     │
└─────────────────────────────────────────────────────────┘
```

#### 4.1.2 核心模块设计

**1. 策略引擎架构**

```python
# 策略基类设计
class StrategyBase(ABC):
    """策略基类，定义策略接口"""
    @abstractmethod
    def setup(self, context: StrategyContext) -> None:
        """策略初始化"""
        pass

    @abstractmethod
    def run(self, context: StrategyContext) -> List[Order]:
        """策略执行，返回交易订单"""
        pass

    @abstractmethod
    def cleanup(self, context: StrategyContext) -> None:
        """策略清理"""
        pass

# 策略上下文
class StrategyContext:
    """策略执行上下文"""
    def __init__(self):
        self.symbol: str
        self.data: pd.DataFrame
        self.portfolio: Portfolio
        self.order_controller: OrderController
        self.current_time: datetime
        self.logger: Logger

# 订单控制器
class OrderController:
    """订单控制器，处理交易逻辑"""
    def __init__(self, context: StrategyContext):
        self.context = context
        self.orders: List[Order] = []
        self.position: Position

    def setup(self, context: StrategyContext) -> None:
        """设置上下文"""
        pass

    def run_order(self, order: Order) -> None:
        """执行订单"""
        pass

    def get_volume(self) -> float:
        """获取当前仓位"""
        pass

    def get_volume_available_now(self) -> float:
        """获取可用仓位"""
        pass
```

**2. 回测系统架构**

```python
class BacktestEngine:
    """回测引擎"""
    def __init__(self):
        self.strategies: Dict[str, StrategyBase]
        self.data_provider: DataProvider
        self.portfolio: PortfolioManager
        self.order_matcher: OrderMatcher
        self.performance_calculator: PerformanceCalculator

    def run_backtest(self, config: BacktestConfig) -> BacktestResult:
        """执行回测"""
        # 1. 初始化
        self._initialize(config)

        # 2. 遍历历史数据
        for timestamp in self._get_time_series():
            self._process_timestamp(timestamp)

        # 3. 计算性能指标
        return self._calculate_performance()

    def _process_timestamp(self, timestamp: datetime) -> None:
        """处理时间戳"""
        # 获取市场数据
        market_data = self.data_provider.get_data(timestamp)

        # 更新投资组合
        self.portfolio.update(market_data)

        # 执行策略
        for strategy in self.strategies.values():
            orders = strategy.run(self.context)
            for order in orders:
                self.order_matcher.process_order(order, market_data)

class TaskScheduler:
    """任务调度器"""
    def __init__(self):
        self.thread_pool: ThreadPoolExecutor
        self.queue: Queue
        self.db_client: MySQLClient

    def start(self) -> None:
        """启动调度器"""
        while self.running:
            # 扫描待执行任务
            pending_tasks = self._get_pending_tasks()

            for task in pending_tasks:
                # 提交到线程池
                self.thread_pool.submit(self._execute_task, task)

            time.sleep(30)  # 30秒检查一次

    def _execute_task(self, task: BacktestTask) -> None:
        """执行回测任务"""
        try:
            # 更新任务状态
            self._update_task_status(task.task_id, 'running', 0)

            # 创建回测引擎
            engine = BacktestEngine()
            config = self._build_backtest_config(task)
            result = engine.run_backtest(config)

            # 保存结果
            self._save_backtest_result(task, result)

            # 更新任务状态
            self._update_task_status(task.task_id, 'completed', 100)

        except Exception as e:
            # 记录错误
            self.logger.error(f"Task {task.task_id} failed: {str(e)}")
            # 更新任务状态
            self._update_task_status(task.task_id, 'failed', 0, str(e))
```

#### 4.1.3 数据库设计

**MySQL表结构**

```sql
-- 策略表
CREATE TABLE strategies (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL UNIQUE COMMENT '策略代码',
    display_name VARCHAR(100) NOT NULL COMMENT '策略显示名称',
    description TEXT COMMENT '策略描述',
    strategy_type VARCHAR(50) NOT NULL COMMENT '策略类型',
    parameters JSON COMMENT '策略参数配置',
    is_active BOOLEAN DEFAULT TRUE COMMENT '是否启用',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_strategy_type (strategy_type),
    INDEX idx_is_active (is_active)
) ENGINE=InnoDB COMMENT='策略表';

-- 回测任务表
CREATE TABLE backtest_tasks (
    id INT PRIMARY KEY AUTO_INCREMENT,
    task_id VARCHAR(100) NOT NULL UNIQUE COMMENT '任务唯一标识',
    strategy_id INT NOT NULL COMMENT '策略ID',
    symbols JSON NOT NULL COMMENT '股票代码列表或指数代码',
    start_time DATETIME NOT NULL COMMENT '回测开始时间',
    end_time DATETIME NOT NULL COMMENT '回测结束时间',
    status ENUM('pending', 'running', 'completed', 'failed', 'cancelled') DEFAULT 'pending' COMMENT '任务状态',
    progress INT DEFAULT 0 COMMENT '进度百分比',
    parameters JSON COMMENT '任务参数',
    result_summary JSON COMMENT '结果摘要',
    error_message TEXT COMMENT '错误信息',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (strategy_id) REFERENCES strategies(id),
    INDEX idx_task_status (status),
    INDEX idx_created_at (created_at),
    INDEX idx_strategy_time (strategy_id, start_time, end_time)
) ENGINE=InnoDB COMMENT='回测任务表';

-- 回测结果表
CREATE TABLE backtest_results (
    id INT PRIMARY KEY AUTO_INCREMENT,
    task_id VARCHAR(100) COMMENT '任务ID',
    strategy_id INT COMMENT '策略ID',
    symbol VARCHAR(20) NOT NULL COMMENT '股票代码',
    name VARCHAR(50) COMMENT '股票名称',
    trending_type VARCHAR(50) COMMENT '趋势类型',
    strategy_name VARCHAR(50) COMMENT '策略名称',
    backtest_start_time DATETIME COMMENT '回测开始时间',
    backtest_end_time DATETIME COMMENT '回测结束时间',
    pnl_ratio DECIMAL(10, 4) COMMENT '累计收益率',
    sharp_ratio DECIMAL(10, 4) COMMENT '夏普比率',
    max_drawdown DECIMAL(10, 4) COMMENT '最大回撤',
    risk_ratio DECIMAL(10, 4) COMMENT '风险比率',
    open_count INT COMMENT '开仓次数',
    close_count INT COMMENT '平仓次数',
    win_count INT COMMENT '盈利次数',
    lose_count INT COMMENT '亏损次数',
    win_ratio DECIMAL(6, 4) COMMENT '胜率',
    total_trades INT COMMENT '总交易次数',
    win_trades INT COMMENT '盈利交易次数',
    current_price DECIMAL(10, 2) COMMENT '当前股价',
    status ENUM('init', 'running', 'finished') DEFAULT 'init' COMMENT '回测状态',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (task_id) REFERENCES backtest_tasks(task_id),
    FOREIGN KEY (strategy_id) REFERENCES strategies(id),
    UNIQUE KEY uk_symbol_time (symbol, backtest_start_time, backtest_end_time),
    INDEX idx_task_id (task_id),
    INDEX idx_symbol (symbol),
    INDEX idx_pnl_ratio (pnl_ratio)
) ENGINE=InnoDB COMMENT='回测结果表';

-- 股票池表
CREATE TABLE stock_symbols (
    id INT PRIMARY KEY AUTO_INCREMENT,
    symbol VARCHAR(20) NOT NULL UNIQUE COMMENT '股票代码',
    name VARCHAR(100) NOT NULL COMMENT '股票名称',
    market VARCHAR(10) DEFAULT 'A' COMMENT '市场类型',
    industry VARCHAR(50) COMMENT '所属行业',
    is_active BOOLEAN DEFAULT TRUE COMMENT '是否启用',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_market (market),
    INDEX idx_industry (industry),
    INDEX idx_is_active (is_active)
) ENGINE=InnoDB COMMENT='股票池表';

-- 交易记录表
CREATE TABLE trades (
    id INT PRIMARY KEY AUTO_INCREMENT,
    task_id VARCHAR(100) COMMENT '任务ID',
    symbol VARCHAR(20) NOT NULL COMMENT '股票代码',
    side ENUM('buy', 'sell') NOT NULL COMMENT '交易方向',
    price DECIMAL(10, 4) NOT NULL COMMENT '交易价格',
    quantity INT NOT NULL COMMENT '交易数量',
    amount DECIMAL(15, 2) NOT NULL COMMENT '交易金额',
    fee DECIMAL(10, 2) DEFAULT 0 COMMENT '手续费',
    timestamp DATETIME NOT NULL COMMENT '交易时间',
    strategy_name VARCHAR(50) COMMENT '策略名称',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (task_id) REFERENCES backtest_tasks(task_id),
    INDEX idx_symbol (symbol),
    INDEX idx_timestamp (timestamp),
    INDEX idx_task_strategy (task_id, strategy_name)
) ENGINE=InnoDB COMMENT='交易记录表';

-- 系统日志表
CREATE TABLE system_logs (
    id INT PRIMARY KEY AUTO_INCREMENT,
    level ENUM('DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL') NOT NULL COMMENT '日志级别',
    module VARCHAR(50) NOT NULL COMMENT '模块名称',
    message TEXT NOT NULL COMMENT '日志内容',
    context JSON COMMENT '上下文信息',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_level (level),
    INDEX idx_module (module),
    INDEX idx_created_at (created_at)
) ENGINE=InnoDB COMMENT='系统日志表';
```

#### 4.1.4 缓存策略

**Redis缓存设计**

```python
# 缓存键值约定
CACHE_KEYS = {
    # 用户相关
    USER_INFO: "user:info:{user_id}",
    USER_TOKEN: "user:token:{token}",
    USER_PERMISSIONS: "user:permissions:{user_id}",

    # 策略相关
    STRATEGY_LIST: "strategy:list",
    STRATEGY_INFO: "strategy:info:{strategy_id}",
    STRATEGY_PERFORMANCE: "strategy:perf:{strategy_id}",

    # 回测相关
    BACKTEST_TASK: "backtest:task:{task_id}",
    BACKTEST_RESULT: "backtest:result:{task_id}",
    BACKTEST_PROGRESS: "backtest:progress:{task_id}",

    # 市场数据
    MARKET_DATA: "market:data:{symbol}:{timeframe}",
    INDEX_CONSTITUENTS: "index:constituents:{index_symbol}",
    REAL_TIME_QUOTE: "realtime:quote:{symbol}",

    # 系统状态
    SYSTEM_STATUS: "system:status",
    ACTIVE_USERS: "system:active_users",
}

class CacheManager:
    """缓存管理器"""
    def __init__(self, redis_client: Redis):
        self.redis = redis_client

    async def get_market_data(self, symbol: str, timeframe: str) -> Optional[pd.DataFrame]:
        """获取市场数据缓存"""
        key = CACHE_KEYS['MARKET_DATA'].format(symbol=symbol, timeframe=timeframe)
        data = await self.redis.get(key)
        if data:
            return pd.read_json(data)
        return None

    async def set_market_data(self, symbol: str, timeframe: str,
                              data: pd.DataFrame, expire: int = 300) -> None:
        """设置市场数据缓存"""
        key = CACHE_KEYS['MARKET_DATA'].format(symbol=symbol, timeframe=timeframe)
        await self.redis.setex(key, expire, data.to_json())

    async def get_backtest_progress(self, task_id: str) -> Optional[int]:
        """获取回测进度"""
        key = CACHE_KEYS['BACKTEST_PROGRESS'].format(task_id=task_id)
        progress = await self.redis.get(key)
        return int(progress) if progress else 0

    async def set_backtest_progress(self, task_id: str, progress: int) -> None:
        """设置回测进度"""
        key = CACHE_KEYS['BACKTEST_PROGRESS'].format(task_id=task_id)
        await self.redis.setex(key, 3600, str(progress))
```

### 4.2 性能优化策略

#### 4.2.1 计算优化

**1. 向量化计算**

```python
import numpy as np
import pandas as pd
from numba import jit

@jit(nopython=True)
def calculate_macd_vectorized(close_prices: np.ndarray, fast: int = 12,
                             slow: int = 26, signal: int = 9) -> tuple:
    """向量化MACD计算"""
    # 使用numpy计算EMA
    ema_fast = np.zeros_like(close_prices)
    ema_slow = np.zeros_like(close_prices)

    alpha_fast = 2.0 / (fast + 1)
    alpha_slow = 2.0 / (slow + 1)

    ema_fast[0] = close_prices[0]
    ema_slow[0] = close_prices[0]

    for i in range(1, len(close_prices)):
        ema_fast[i] = alpha_fast * close_prices[i] + (1 - alpha_fast) * ema_fast[i-1]
        ema_slow[i] = alpha_slow * close_prices[i] + (1 - alpha_slow) * ema_slow[i-1]

    macd_line = ema_fast - ema_slow

    # 计算信号线
    signal_line = np.zeros_like(macd_line)
    signal_line[0] = macd_line[0]

    alpha_signal = 2.0 / (signal + 1)
    for i in range(1, len(macd_line)):
        signal_line[i] = alpha_signal * macd_line[i] + (1 - alpha_signal) * signal_line[i-1]

    histogram = macd_line - signal_line

    return macd_line, signal_line, histogram
```

**2. 并行计算**

```python
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor
import multiprocessing

class ParallelBacktest:
    """并行回测执行"""
    def __init__(self, max_workers: int = None):
        self.max_workers = max_workers or multiprocessing.cpu_count()

    def run_parallel_backtest(self, tasks: List[BacktestTask]) -> List[BacktestResult]:
        """并行执行回测任务"""
        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            # 提交所有任务
            future_to_task = {
                executor.submit(self._execute_single_backtest, task): task
                for task in tasks
            }

            results = []
            for future in concurrent.futures.as_completed(future_to_task):
                try:
                    result = future.result()
                    results.append(result)
                except Exception as e:
                    task = future_to_task[future]
                    self.logger.error(f"Task {task.task_id} failed: {str(e)}")

            return results

    def _execute_single_backtest(self, task: BacktestTask) -> BacktestResult:
        """执行单个回测任务"""
        engine = BacktestEngine()
        config = self._build_config(task)
        return engine.run_backtest(config)
```

**3. 内存优化**

```python
class DataLoader:
    """数据加载器，优化内存使用"""
    def __init__(self, chunk_size: int = 10000):
        self.chunk_size = chunk_size

    def load_history_data(self, symbol: str, start_date: str, end_date: str) -> pd.DataFrame:
        """分块加载历史数据"""
        query = f"""
            SELECT timestamp, open, high, low, close, volume
            FROM market_data
            WHERE symbol = %s AND timestamp BETWEEN %s AND %s
            ORDER BY timestamp
        """

        chunks = []
        for chunk in pd.read_sql(query, self.db, params=[symbol, start_date, end_date],
                                 chunksize=self.chunk_size):
            chunks.append(chunk)

        return pd.concat(chunks, ignore_index=True)

    def process_data_streaming(self, symbol: str, start_date: str, end_date: str):
        """流式处理数据"""
        query = """
            SELECT timestamp, open, high, low, close, volume
            FROM market_data
            WHERE symbol = %s AND timestamp BETWEEN %s AND %s
            ORDER BY timestamp
        """

        with self.db.cursor() as cursor:
            cursor.execute(query, (symbol, start_date, end_date))
            while True:
                row = cursor.fetchone()
                if not row:
                    break
                yield self._convert_to_dataframe(row)
```

#### 4.2.2 数据库优化

**1. 索引优化**

```sql
-- 复合索引优化回测查询
CREATE INDEX idx_backtest_composite ON backtest_results (
    strategy_id, backtest_start_time, backtest_end_time, pnl_ratio
);

-- 分区表优化大数据量
ALTER TABLE backtest_results PARTITION BY RANGE (YEAR(backtest_start_time)) (
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p2025 VALUES LESS THAN (2026),
    PARTITION pmax VALUES LESS THAN MAXVALUE
);

-- 读写分离
-- 主库：处理写操作
-- 从库：处理读操作
```

**2. 查询优化**

```python
class BacktestRepository:
    """回测结果仓库，优化查询性能"""
    def __init__(self, db_client: MySQLClient):
        self.db = db_client

    async def get_paginated_results(self, page: int, per_page: int,
                                   filters: dict) -> PaginatedResult:
        """分页查询回测结果"""
        # 构建查询
        query = """
            SELECT id, symbol, name, strategy_name, pnl_ratio, sharp_ratio,
                   max_drawdown, win_ratio, created_at
            FROM backtest_results
            WHERE 1=1
        """
        params = []

        # 应用过滤条件
        if filters.get('strategy_name'):
            query += " AND strategy_name = %s"
            params.append(filters['strategy_name'])

        if filters.get('start_date'):
            query += " AND backtest_start_time >= %s"
            params.append(filters['start_date'])

        if filters.get('end_date'):
            query += " AND backtest_end_time <= %s"
            params.append(filters['end_date'])

        # 获取总数
        count_query = f"SELECT COUNT(*) as total FROM ({query}) as subquery"
        total = await self.db.fetch_one(count_query, params)['total']

        # 分页
        offset = (page - 1) * per_page
        query += f" ORDER BY created_at DESC LIMIT {per_page} OFFSET {offset}"

        # 执行查询
        results = await self.db.fetch_all(query, params)

        return PaginatedResult(
            data=results,
            total=total,
            page=page,
            per_page=per_page,
            total_pages=(total + per_page - 1) // per_page
        )
```

### 4.3 实时数据处理

#### 4.3.1 WebSocket推送架构

```python
class WebSocketManager:
    """WebSocket连接管理器"""
    def __init__(self):
        self.active_connections: Dict[str, WebSocket] = {}
        self.connection_pools: Dict[str, Set[WebSocket]] = defaultdict(set)

    async def connect(self, websocket: WebSocket, user_id: str, topic: str):
        """建立连接"""
        await websocket.accept()
        self.active_connections[user_id] = websocket
        self.connection_pools[topic].add(websocket)

    async def disconnect(self, user_id: str, topic: str):
        """断开连接"""
        if user_id in self.active_connections:
            del self.active_connections[user_id]
        if topic in self.connection_pools:
            self.connection_pools[topic].discard(user_id)

    async def broadcast_to_topic(self, topic: str, message: dict):
        """向主题广播消息"""
        if topic not in self.connection_pools:
            return

        disconnected = []
        for connection in self.connection_pools[topic]:
            try:
                await connection.send_json(message)
            except WebSocketDisconnect:
                disconnected.append(connection)

        # 清理断开的连接
        for conn in disconnected:
            self.connection_pools[topic].discard(conn)

class RealTimeDataProcessor:
    """实时数据处理器"""
    def __init__(self, ws_manager: WebSocketManager):
        self.ws_manager = ws_manager
        self.redis_subscriber = redis_client.pubsub()

    async def start_market_data_stream(self):
        """启动行情数据流"""
        # 订阅Redis频道
        self.redis_subscriber.subscribe('market_data_updates')

        async for message in self.redis_subscriber.listen():
            if message['type'] == 'message':
                data = json.loads(message['data'])
                # 广播到订阅者
                await self.ws_manager.broadcast_to_topic(
                    f"market_data_{data['symbol']}",
                    {
                        'type': 'market_update',
                        'data': data
                    }
                )

    async def send_backtest_progress(self, task_id: str, progress: int):
        """发送回测进度更新"""
        await self.ws_manager.broadcast_to_topic(
            f"backtest_progress_{task_id}",
            {
                'type': 'progress_update',
                'task_id': task_id,
                'progress': progress
            }
        )
```

#### 4.3.2 事件驱动架构

```python
from event_bus import EventBus
from typing import Callable

class EventBus:
    """事件总线"""
    def __init__(self):
        self.subscribers: Dict[str, List[Callable]] = defaultdict(list)

    def subscribe(self, event_type: str, handler: Callable):
        """订阅事件"""
        self.subscribers[event_type].append(handler)

    async def publish(self, event_type: str, data: dict):
        """发布事件"""
        if event_type in self.subscribers:
            for handler in self.subscribers[event_type]:
                await handler(data)

# 事件定义
EVENTS = {
    'BACKTEST_STARTED': 'backtest_started',
    'BACKTEST_PROGRESS': 'backtest_progress',
    'BACKTEST_COMPLETED': 'backtest_completed',
    'TRADE_EXECUTED': 'trade_executed',
    'RISK_ALERT': 'risk_alert',
}

# 事件处理器
class EventHandlers:
    def __init__(self, event_bus: EventBus, ws_manager: WebSocketManager):
        self.event_bus = event_bus
        self.ws_manager = ws_manager
        self._register_handlers()

    def _register_handlers(self):
        """注册事件处理器"""
        self.event_bus.subscribe(EVENTS['BACKTEST_STARTED'], self.on_backtest_started)
        self.event_bus.subscribe(EVENTS['BACKTEST_PROGRESS'], self.on_backtest_progress)
        self.event_bus.subscribe(EVENTS['BACKTEST_COMPLETED'], self.on_backtest_completed)

    async def on_backtest_started(self, data: dict):
        """回测开始事件"""
        await self.ws_manager.broadcast_to_topic(
            f"backtest_{data['task_id']}",
            {
                'type': 'backtest_started',
                'data': data
            }
        )

    async def on_backtest_progress(self, data: dict):
        """回测进度事件"""
        await self.ws_manager.broadcast_to_topic(
            f"backtest_{data['task_id']}",
            {
                'type': 'progress_update',
                'progress': data['progress']
            }
        )
```

---

## 5. 前端UI/UX设计

### 5.1 设计理念

#### 5.1.1 核心原则

1. **专业性**：为专业交易员和研究人员设计，提供强大的数据可视化
2. **易用性**：简化操作流程，降低学习成本
3. **响应性**：实时数据更新，快速响应用户操作
4. **一致性**：统一的设计语言和交互模式
5. **可扩展性**：支持插件式组件扩展

#### 5.1.2 用户体验目标

- **新手用户**：30分钟内完成首次回测
- **专业用户**：5秒内找到所需功能
- **响应时间**：界面操作反馈 < 100ms
- **数据加载**：首屏加载 < 2秒，后续数据 < 500ms

### 5.2 信息架构

#### 5.2.1 网站地图

```
首页 (Dashboard)
├── 实时行情 (Market)
│   ├── 大盘指数
│   ├── 行业板块
│   ├── 个股行情
│   └── 资金流向
├── 回测中心 (Backtest)
│   ├── 创建回测
│   ├── 任务列表
│   ├── 回测报告
│   └── 历史回测
├── 策略管理 (Strategy)
│   ├── 策略库
│   ├── 我的策略
│   ├── 策略编辑器
│   └── 策略分析
├── 交易监控 (Trading)
│   ├── 实时信号
│   ├── 持仓管理
│   ├── 交易记录
│   └── 风险监控
├── 投资组合 (Portfolio)
│   ├── 资产总览
│   ├── 持仓分析
│   ├── 收益分析
│   └── 风险指标
├── 报表分析 (Reports)
│   ├── 绩效报告
│   ├── 归因分析
│   ├── 对比分析
│   └── 自定义报表
├── 系统管理 (System)
│   ├── 用户管理
│   ├── 权限配置
│   ├── 数据源配置
│   └── 系统监控
└── 帮助中心 (Help)
    ├── 使用指南
    ├── 常见问题
    ├── API文档
    └── 联系我们
```

#### 5.2.2 导航设计

**主导航（侧边栏）**
- 固定位置：左侧
- 宽度：240px（展开）/ 64px（折叠）
- 层级：最多2级
- 状态：当前页面高亮显示

**面包屑导航**
- 位置：页面顶部，主导航下方
- 格式：首页 > 模块 > 子模块 > 当前页面
- 点击：可快速返回上级页面

**快捷菜单**
- 位置：右上角用户头像旁
- 功能：常用功能快速访问
- 内容：创建回测、新建策略、查看报告等

### 5.3 页面布局设计

#### 5.3.1 通用布局

```tsx
// 通用页面布局组件
const PageLayout: React.FC<{
  title: string;
  subtitle?: string;
  actions?: React.ReactNode;
  children: React.ReactNode;
}> = ({ title, subtitle, actions, children }) => {
  return (
    <div className="page-container">
      {/* 页面头部 */}
      <div className="page-header">
        <div className="page-title-section">
          <h1 className="page-title">{title}</h1>
          {subtitle && <p className="page-subtitle">{subtitle}</p>}
        </div>
        {actions && <div className="page-actions">{actions}</div>}
      </div>

      {/* 页面内容 */}
      <div className="page-content">
        {children}
      </div>
    </div>
  );
};

// 使用示例
<PageLayout
  title="回测中心"
  subtitle="创建和管理您的量化交易策略回测"
  actions={<Button type="primary">新建回测</Button>}
>
  <DataTable columns={columns} data={data} />
</PageLayout>
```

#### 5.3.2 仪表盘布局

```tsx
// 仪表盘网格系统
const Dashboard: React.FC = () => {
  return (
    <div className="dashboard">
      {/* 关键指标卡片行 */}
      <div className="dashboard-row">
        <MetricCard className="col-span-1" />
        <MetricCard className="col-span-1" />
        <MetricCard className="col-span-1" />
        <MetricCard className="col-span-1" />
      </div>

      {/* 图表行 */}
      <div className="dashboard-row">
        <ChartCard className="col-span-2">
          <ReturnChart />
        </ChartCard>
        <ChartCard className="col-span-1">
          <PositionChart />
        </ChartCard>
      </div>

      {/* 列表行 */}
      <div className="dashboard-row">
        <div className="col-span-1">
          <RecentTrades />
        </div>
        <div className="col-span-1">
          <ActiveStrategies />
        </div>
      </div>
    </div>
  );
};
```

### 5.4 组件设计系统

#### 5.4.1 设计令牌 (Design Tokens)

```css
/* 颜色系统 */
:root {
  /* 主色 */
  --brand-primary: #4f46e5;
  --brand-primary-light: #6366f1;
  --brand-primary-dark: #3730a3;

  /* 辅助色 */
  --brand-secondary: #06b6d4;
  --brand-accent: #8b5cf6;

  /* 功能色 */
  --success: #10b981;
  --warning: #f59e0b;
  --error: #ef4444;
  --info: #3b82f6;

  /* 语义色 */
  --buy: #10b981;
  --sell: #ef4444;

  /* 背景色 */
  --bg-primary: #ffffff;
  --bg-secondary: #f9fafb;
  --bg-tertiary: #f3f4f6;
  --bg-hover: #e5e7eb;

  /* 文本色 */
  --text-primary: #111827;
  --text-secondary: #6b7280;
  --text-tertiary: #9ca3af;
  --text-inverse: #ffffff;

  /* 边框 */
  --border-color: #e5e7eb;
  --border-radius: 0.5rem;
  --border-radius-lg: 1rem;

  /* 阴影 */
  --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);

  /* 字体 */
  --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
  --font-mono: 'Fira Code', 'Monaco', 'Consolas', monospace;

  /* 字号 */
  --text-xs: 0.75rem;
  --text-sm: 0.875rem;
  --text-base: 1rem;
  --text-lg: 1.125rem;
  --text-xl: 1.25rem;
  --text-2xl: 1.5rem;
  --text-3xl: 1.875rem;

  /* 间距 */
  --space-1: 0.25rem;
  --space-2: 0.5rem;
  --space-3: 0.75rem;
  --space-4: 1rem;
  --space-6: 1.5rem;
  --space-8: 2rem;
  --space-12: 3rem;
  --space-16: 4rem;

  /* 断点 */
  --breakpoint-sm: 640px;
  --breakpoint-md: 768px;
  --breakpoint-lg: 1024px;
  --breakpoint-xl: 1280px;
}

/* 深色主题 */
[data-theme="dark"] {
  --bg-primary: #0f172a;
  --bg-secondary: #1e293b;
  --bg-tertiary: #334155;
  --bg-hover: #475569;

  --text-primary: #f1f5f9;
  --text-secondary: #cbd5e1;
  --text-tertiary: #94a3b8;

  --border-color: #334155;
}
```

#### 5.4.2 核心组件

**1. 数据表格组件**

```tsx
// 高级数据表格组件
interface DataTableProps<T> {
  columns: Column<T>[];
  data: T[];
  loading?: boolean;
  pagination?: PaginationConfig;
  sorting?: SortConfig;
  filtering?: FilterConfig;
  rowSelection?: RowSelectionConfig<T>;
  onRowClick?: (record: T) => void;
}

const DataTable = <T extends Record<string, any>>({
  columns,
  data,
  loading,
  pagination,
  sorting,
  filtering,
  rowSelection,
  onRowClick
}: DataTableProps<T>) => {
  const [internalData, setInternalData] = useState(data);
  const [sortConfig, setSortConfig] = useState<SortConfig | null>(sorting);

  // 排序处理
  const handleSort = (key: string) => {
    let newSortConfig: SortConfig;
    if (sortConfig?.key === key) {
      newSortConfig = {
        key,
        order: sortConfig.order === 'asc' ? 'desc' : 'asc'
      };
    } else {
      newSortConfig = { key, order: 'asc' };
    }

    setSortConfig(newSortConfig);

    // 执行排序
    const sorted = [...internalData].sort((a, b) => {
      const aVal = a[key];
      const bVal = b[key];

      if (aVal < bVal) return newSortConfig.order === 'asc' ? -1 : 1;
      if (aVal > bVal) return newSortConfig.order === 'asc' ? 1 : -1;
      return 0;
    });

    setInternalData(sorted);
  };

  return (
    <div className="data-table">
      {/* 表格工具栏 */}
      {(filtering || rowSelection) && (
        <div className="table-toolbar">
          {filtering && <TableFilter />}
          {rowSelection && <TableSelection />}
        </div>
      )}

      {/* 表格主体 */}
      <div className="table-wrapper">
        <table className="table">
          <thead className="table-header">
            <tr>
              {rowSelection && (
                <th className="table-header-cell">
                  <Checkbox
                    checked={rowSelection.selectedRowKeys.length === data.length}
                    onChange={rowSelection.onSelectAll}
                  />
                </th>
              )}
              {columns.map(col => (
                <th
                  key={col.key}
                  className={cn(
                    'table-header-cell',
                    col.sortable && 'sortable',
                    sortConfig?.key === col.key && `sorted-${sortConfig?.order}`
                  )}
                  style={{ width: col.width }}
                  onClick={col.sortable ? () => handleSort(col.key) : undefined}
                >
                  <div className="header-cell-content">
                    <span>{col.title}</span>
                    {col.sortable && (
                      <ChevronUpDown className="sort-icon" />
                    )}
                  </div>
                </th>
              ))}
            </tr>
          </thead>
          <tbody className="table-body">
            {loading ? (
              <tr>
                <td colSpan={columns.length + (rowSelection ? 1 : 0)}>
                  <div className="loading-row">
                    <Spinner />
                    <span>加载中...</span>
                  </div>
                </td>
              </tr>
            ) : internalData.length === 0 ? (
              <tr>
                <td colSpan={columns.length + (rowSelection ? 1 : 0)}>
                  <div className="empty-row">
                    <Empty description="暂无数据" />
                  </div>
                </td>
              </tr>
            ) : (
              internalData.map((record, index) => (
                <tr
                  key={record.id || index}
                  className={cn(
                    'table-row',
                    onRowClick && 'clickable',
                    rowSelection?.selectedRowKeys.includes(record.id) && 'selected'
                  )}
                  onClick={() => onRowClick?.(record)}
                >
                  {rowSelection && (
                    <td className="table-cell">
                      <Checkbox
                        checked={rowSelection.selectedRowKeys.includes(record.id)}
                        onChange={() => rowSelection.onSelect(record)}
                      />
                    </td>
                  )}
                  {columns.map(col => (
                    <td key={col.key} className="table-cell">
                      {col.render ? col.render(record[col.key], record) : record[col.key]}
                    </td>
                  ))}
                </tr>
              ))
            )}
          </tbody>
        </table>
      </div>

      {/* 分页 */}
      {pagination && (
        <div className="table-pagination">
          <Pagination {...pagination} />
        </div>
      )}
    </div>
  );
};
```

**2. 图表组件**

```tsx
// 图表容器组件
interface ChartContainerProps {
  title: string;
  subtitle?: string;
  actions?: React.ReactNode;
  height?: string;
  loading?: boolean;
  children: React.ReactNode;
}

const ChartContainer: React.FC<ChartContainerProps> = ({
  title,
  subtitle,
  actions,
  height = '400px',
  loading,
  children
}) => {
  return (
    <div className="chart-card">
      <div className="chart-header">
        <div className="chart-title-section">
          <h3 className="chart-title">{title}</h3>
          {subtitle && <p className="chart-subtitle">{subtitle}</p>}
        </div>
        {actions && <div className="chart-actions">{actions}</div>}
      </div>

      <div className="chart-content" style={{ height }}>
        {loading ? (
          <div className="chart-loading">
            <Spinner />
            <span>加载中...</span>
          </div>
        ) : (
          children
        )}
      </div>
    </div>
  );
};

// K线图组件
const CandlestickChart: React.FC<{
  data: CandlestickData[];
  indicators?: IndicatorConfig[];
}> = ({ data, indicators }) => {
  return (
    <ResponsiveContainer width="100%" height="100%">
      <ComposedChart data={data}>
        <XAxis
          dataKey="timestamp"
          tickFormatter={formatTimestamp}
          tick={{ fontSize: 12 }}
        />
        <YAxis
          domain={['dataMin', 'dataMax']}
          tick={{ fontSize: 12 }}
          tickFormatter={formatPrice}
        />

        {/* K线图 */}
        <Candlestick
          dataKey="open"
          dataKeyClose="close"
          dataKeyHigh="high"
          dataKeyLow="low"
          stroke="#10b981"
          fill="#10b981"
        />

        {/* 移动平均线 */}
        {indicators?.map((indicator, index) => (
          <Line
            key={indicator.name}
            type="monotone"
            dataKey={indicator.key}
            stroke={indicator.color}
            strokeWidth={2}
            dot={false}
          />
        ))}

        {/* 成交量 */}
        <Bar dataKey="volume" fill="#64748b" opacity={0.3} />

        <Tooltip
          content={<CustomTooltip />}
          cursor={{ strokeDasharray: '3 3' }}
        />

        <Legend />
      </ComposedChart>
    </ResponsiveContainer>
  );
};
```

**3. 指标卡片组件**

```tsx
interface MetricCardProps {
  title: string;
  value: string | number;
  change?: string;
  changeType?: 'positive' | 'negative' | 'neutral';
  icon?: React.ReactNode;
  trend?: 'up' | 'down' | 'flat';
  data?: number[];
  suffix?: string;
}

const MetricCard: React.FC<MetricCardProps> = ({
  title,
  value,
  change,
  changeType = 'neutral',
  icon,
  trend,
  data,
  suffix
}) => {
  return (
    <div className="metric-card">
      <div className="metric-header">
        <div className="metric-icon">{icon}</div>
        <div className="metric-title">{title}</div>
      </div>

      <div className="metric-content">
        <div className="metric-value">
          {typeof value === 'number' ? value.toLocaleString() : value}
          {suffix && <span className="metric-suffix">{suffix}</span>}
        </div>

        {change && (
          <div className={cn('metric-change', `change-${changeType}`)}>
            {changeType === 'positive' && <TrendingUp className="w-4 h-4" />}
            {changeType === 'negative' && <TrendingDown className="w-4 h-4" />}
            <span>{change}</span>
          </div>
        )}
      </div>

      {data && (
        <div className="metric-trend">
          <ResponsiveContainer width="100%" height="40">
            <AreaChart data={data.map((val, idx) => ({ idx, val }))}>
              <Area
                type="monotone"
                dataKey="val"
                stroke={trend === 'up' ? '#10b981' : '#ef4444'}
                fillOpacity={0.1}
                strokeWidth={2}
              />
            </AreaChart>
          </ResponsiveContainer>
        </div>
      )}
    </div>
  );
};
```

### 5.5 响应式设计

#### 5.5.1 断点系统

```css
/* 断点定义 */
@media (min-width: 640px) { /* sm */ }
@media (min-width: 768px) { /* md */ }
@media (min-width: 1024px) { /* lg */ }
@media (min-width: 1280px) { /* xl */ }
@media (min-width: 1536px) { /* 2xl */ }

/* 网格系统 */
.grid {
  display: grid;
  grid-template-columns: repeat(12, 1fr);
  gap: 1rem;
}

.col-span-1 { grid-column: span 1 / span 1; }
.col-span-2 { grid-column: span 2 / span 2; }
.col-span-3 { grid-column: span 3 / span 3; }
.col-span-4 { grid-column: span 4 / span 4; }
.col-span-6 { grid-column: span 6 / span 6; }
.col-span-12 { grid-column: span 12 / span 12; }

/* 响应式列数 */
@media (max-width: 768px) {
  .grid-responsive {
    grid-template-columns: 1fr;
  }
}

@media (min-width: 769px) and (max-width: 1024px) {
  .grid-responsive {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (min-width: 1025px) {
  .grid-responsive {
    grid-template-columns: repeat(4, 1fr);
  }
}
```

#### 5.5.2 移动端优化

```tsx
// 移动端适配组件
const MobileOptimized: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const isMobile = useMediaQuery('(max-width: 768px)');

  return (
    <div className={cn('mobile-optimized', isMobile && 'is-mobile')}>
      {children}
    </div>
  );
};

// 移动端导航
const MobileNav: React.FC = () => {
  return (
    <nav className="mobile-nav">
      <BottomNavigation>
        <BottomNavigationItem
          icon={<DashboardIcon />}
          label="首页"
          path="/"
        />
        <BottomNavigationItem
          icon={<MarketIcon />}
          label="行情"
          path="/market"
        />
        <BottomNavigationItem
          icon={<BacktestIcon />}
          label="回测"
          path="/backtest"
        />
        <BottomNavigationItem
          icon={<StrategyIcon />}
          label="策略"
          path="/strategy"
        />
        <BottomNavigationItem
          icon={<ProfileIcon />}
          label="我的"
          path="/profile"
        />
      </BottomNavigation>
    </nav>
  );
};
```

### 5.6 主题定制

#### 5.6.1 主题切换

```tsx
// 主题上下文
const ThemeContext = createContext<ThemeContextType | null>(null);

export const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [theme, setTheme] = useState<Theme>(() => {
    const saved = localStorage.getItem('theme');
    return (saved as Theme) || 'light';
  });

  useEffect(() => {
    localStorage.setItem('theme', theme);
    document.documentElement.setAttribute('data-theme', theme);
  }, [theme]);

  const value = {
    theme,
    setTheme: (newTheme: Theme) => setTheme(newTheme),
    toggleTheme: () => setTheme(prev => prev === 'light' ? 'dark' : 'light')
  };

  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
};

// 主题切换按钮
const ThemeToggle: React.FC = () => {
  const { theme, toggleTheme } = useTheme();

  return (
    <Button
      variant="ghost"
      size="icon"
      onClick={toggleTheme}
      className="theme-toggle"
    >
      {theme === 'light' ? (
        <Moon className="w-5 h-5" />
      ) : (
        <Sun className="w-5 h-5" />
      )}
    </Button>
  );
};
```

#### 5.6.2 自定义主题

```tsx
// 主题配置
interface ThemeConfig {
  colors: {
    primary: string;
    secondary: string;
    accent: string;
    background: string;
    surface: string;
    text: string;
    success: string;
    warning: string;
    error: string;
  };
  typography: {
    fontFamily: string;
    fontSize: {
      xs: string;
      sm: string;
      base: string;
      lg: string;
      xl: string;
    };
  };
  spacing: {
    xs: string;
    sm: string;
    md: string;
    lg: string;
    xl: string;
  };
  borderRadius: {
    sm: string;
    md: string;
    lg: string;
  };
  shadows: {
    sm: string;
    md: string;
    lg: string;
  };
}

// 预设主题
const PRESET_THEMES: Record<string, ThemeConfig> = {
  default: {
    colors: {
      primary: '#4f46e5',
      // ... 其他颜色
    },
    typography: {
      fontFamily: '-apple-system, BlinkMacSystemFont, sans-serif',
      // ... 其他字体
    },
    // ... 其他配置
  },
  dark: {
    colors: {
      primary: '#6366f1',
      // ... 其他颜色
    },
    // ... 其他配置
  },
  professional: {
    colors: {
      primary: '#1e293b',
      // ... 专业主题配色
    },
    // ... 其他配置
  }
};

// 主题编辑器
const ThemeEditor: React.FC = () => {
  const [selectedTheme, setSelectedTheme] = useState('default');
  const [customConfig, setCustomConfig] = useState<ThemeConfig | null>(null);

  const applyTheme = (config: ThemeConfig) => {
    // 动态应用主题
    const root = document.documentElement;
    Object.entries(config.colors).forEach(([key, value]) => {
      root.style.setProperty(`--color-${key}`, value);
    });
  };

  return (
    <div className="theme-editor">
      <div className="theme-selector">
        {Object.keys(PRESET_THEMES).map(theme => (
          <ThemePreview
            key={theme}
            name={theme}
            config={PRESET_THEMES[theme]}
            selected={selectedTheme === theme}
            onClick={() => setSelectedTheme(theme)}
          />
        ))}
      </div>

      {selectedTheme === 'custom' && (
        <ThemeConfigurator
          config={customConfig}
          onChange={setCustomConfig}
        />
      )}
    </div>
  );
};
```

### 5.7 无障碍设计

#### 5.7.1 键盘导航

```tsx
// 键盘导航支持
const KeyboardNavigation: React.FC = () => {
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Ctrl/Cmd + K: 打开命令面板
      if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
        e.preventDefault();
        openCommandPalette();
      }

      // Esc: 关闭模态框
      if (e.key === 'Escape') {
        closeModals();
      }

      // Tab: 导航
      if (e.key === 'Tab') {
        // 焦点管理逻辑
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, []);

  return null;
};

// 焦点管理
const FocusManager: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const focusableElements = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';

  return (
    <div
      onKeyDown={(e) => {
        if (e.key === 'Tab') {
          const focusable = Array.from(
            document.querySelectorAll<HTMLElement>(focusableElements)
          );
          const first = focusable[0];
          const last = focusable[focusable.length - 1];

          if (e.shiftKey) {
            if (document.activeElement === first) {
              last.focus();
              e.preventDefault();
            }
          } else {
            if (document.activeElement === last) {
              first.focus();
              e.preventDefault();
            }
          }
        }
      }}
    >
      {children}
    </div>
  );
};
```

#### 5.7.2 屏幕阅读器支持

```tsx
// ARIA标签
<Button
  aria-label="删除回测任务"
  aria-describedby="delete-button-description"
  onClick={handleDelete}
>
  <TrashIcon />
</Button>
<div id="delete-button-description" className="sr-only">
  此操作将永久删除选中的回测任务，且无法恢复
</div>

// 状态指示
<div
  role="status"
  aria-live="polite"
  aria-atomic="true"
>
  {status === 'loading' && '正在加载...'}
  {status === 'success' && '加载完成'}
  {status === 'error' && '加载失败'}
</div>

// 进度指示
<ProgressBar
  value={progress}
  max={100}
  aria-valuenow={progress}
  aria-valuemin={0}
  aria-valuemax={100}
  aria-label={`回测进度: ${progress}%`}
/>
```

---

## 6. 性能优化策略

### 6.1 前端性能优化

#### 6.1.1 代码分割

```tsx
// 路由级代码分割
const Dashboard = lazy(() => import('@/pages/Dashboard'));
const Market = lazy(() => import('@/pages/Market'));
const Backtest = lazy(() => import('@/pages/Backtest'));

// 组件级代码分割
const Chart = lazy(() => import('@/components/Chart'));
const DataTable = lazy(() => import('@/components/DataTable'));

// 懒加载包装
const LazyWrapper: React.FC<{ children: React.ComponentType }> = ({ children: Component }) => (
  <Suspense fallback={<div className="loading-spinner">加载中...</div>}>
    <Component />
  </Suspense>
);

// 使用
<Routes>
  <Route path="/" element={<LazyWrapper component={Dashboard} />} />
  <Route path="/market" element={<LazyWrapper component={Market} />} />
</Routes>
```

#### 6.1.2 虚拟滚动

```tsx
// 大数据列表虚拟化
import { FixedSizeList as List } from 'react-window';

const VirtualizedList: React.FC<{ items: any[] }> = ({ items }) => {
  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => (
    <div style={style}>
      <ListItem item={items[index]} />
    </div>
  );

  return (
    <List
      height={600}        // 容器高度
      itemCount={items.length}
      itemSize={80}       // 每行高度
      width="100%"
    >
      {Row}
    </List>
  );
};

// 数据表格虚拟化
const VirtualizedTable: React.FC<{ data: any[] }> = ({ data }) => {
  return (
    <div className="virtualized-table">
      {/* 表头固定 */}
      <div className="table-header">
        {columns.map(col => (
          <div key={col.key} className="header-cell">
            {col.title}
          </div>
        ))}
      </div>

      {/* 虚拟滚动内容 */}
      <div className="table-body" style={{ height: '500px' }}>
        <FixedSizeList
          height={500}
          itemCount={data.length}
          itemSize={50}
          width="100%"
        >
          {({ index, style }) => (
            <div style={style} className="table-row">
              {columns.map(col => (
                <div key={col.key} className="table-cell">
                  {data[index][col.key]}
                </div>
              ))}
            </div>
          )}
        </FixedSizeList>
      </div>
    </div>
  );
};
```

#### 6.1.3 状态管理优化

```tsx
// 使用Zustand进行轻量级状态管理
import create from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';

interface AppState {
  // 状态
  user: User | null;
  strategies: Strategy[];
  backtestTasks: BacktestTask[];
  theme: Theme;

  // 操作
  setUser: (user: User | null) => void;
  addStrategy: (strategy: Strategy) => void;
  updateBacktestTask: (taskId: string, updates: Partial<BacktestTask>) => void;
  setTheme: (theme: Theme) => void;
}

const useAppStore = create<AppState>()(
  subscribeWithSelector((set, get) => ({
    // 初始状态
    user: null,
    strategies: [],
    backtestTasks: [],
    theme: 'light',

    // 操作
    setUser: (user) => set({ user }),

    addStrategy: (strategy) => set((state) => ({
      strategies: [...state.strategies, strategy]
    })),

    updateBacktestTask: (taskId, updates) => set((state) => ({
      backtestTasks: state.backtestTasks.map(task =>
        task.task_id === taskId ? { ...task, ...updates } : task
      )
    })),

    setTheme: (theme) => set({ theme })
  }))
);

// 选择性订阅，避免不必要的重渲染
const Component: React.FC = () => {
  // 只订阅需要的状态
  const user = useAppStore(state => state.user);
  const strategies = useAppStore(state => state.strategies);

  return (
    <div>
      <h1>{user?.name}</h1>
      <ul>
        {strategies.map(strategy => (
          <li key={strategy.id}>{strategy.name}</li>
        ))}
      </ul>
    </div>
  );
};

// 使用Immer进行不可变状态更新
import { produce } from 'immer';

const updateStrategy = (strategyId: string, updates: Partial<Strategy>) => {
  useAppStore.setState(produce((draft) => {
    const index = draft.strategies.findIndex(s => s.id === strategyId);
    if (index !== -1) {
      draft.strategies[index] = { ...draft.strategies[index], ...updates };
    }
  }));
};
```

#### 6.1.4 缓存策略

```tsx
// React Query数据缓存
import { useQuery, useMutation, useQueryClient } from 'react-query';

// 查询缓存
const useBacktestResults = (filters: FilterOptions) => {
  return useQuery(
    ['backtest-results', filters],
    () => fetchBacktestResults(filters),
    {
      staleTime: 5 * 60 * 1000,      // 5分钟内数据视为新鲜
      cacheTime: 10 * 60 * 1000,     // 10分钟缓存
      refetchOnWindowFocus: false,    // 窗口聚焦时不重新获取
      retry: 3,                      // 失败重试3次
    }
  );
};

// 乐观更新
const useCreateBacktest = () => {
  const queryClient = useQueryClient();

  return useMutation(
    (config: BacktestConfig) => createBacktest(config),
    {
      onMutate: async (newConfig) => {
        // 取消相关查询
        await queryClient.cancelQueries(['backtest-tasks']);

        // 快照之前的数据
        const previousTasks = queryClient.getQueryData(['backtest-tasks']);

        // 乐观更新
        queryClient.setQueryData(['backtest-tasks'], (old: any[]) => [
          ...old,
          { id: 'temp-' + Date.now(), status: 'pending', ...newConfig }
        ]);

        return { previousTasks };
      },

      onError: (err, newConfig, context) => {
        // 回滚到之前的数据
        if (context?.previousTasks) {
          queryClient.setQueryData(['backtest-tasks'], context.previousTasks);
        }
      },

      onSettled: () => {
        // 最终同步服务器数据
        queryClient.invalidateQueries(['backtest-tasks']);
      }
    }
  );
};

// 本地缓存
const useLocalCache = () => {
  const setCache = (key: string, data: any, expireTime: number = 3600000) => {
    const item = {
      data,
      expireTime: Date.now() + expireTime
    };
    localStorage.setItem(key, JSON.stringify(item));
  };

  const getCache = (key: string) => {
    const itemStr = localStorage.getItem(key);
    if (!itemStr) return null;

    const item = JSON.parse(itemStr);
    if (Date.now() > item.expireTime) {
      localStorage.removeItem(key);
      return null;
    }

    return item.data;
  };

  return { setCache, getCache };
};
```

### 6.2 后端性能优化

#### 6.2.1 数据库查询优化

```python
# 查询优化示例
class BacktestRepository:
    def __init__(self, db: AsyncSession):
        self.db = db

    async def get_results_with_pagination(
        self,
        page: int = 1,
        per_page: int = 20,
        filters: dict = None
    ) -> PaginatedResult:
        """优化的分页查询"""
        # 1. 使用索引字段作为过滤条件
        query = select(BackTestResult)

        if filters:
            # 组合索引优化
            if filters.get('strategy_id') and filters.get('start_date'):
                query = query.where(
                    and_(
                        BackTestResult.strategy_id == filters['strategy_id'],
                        BackTestResult.backtest_start_time >= filters['start_date']
                    )
                )

        # 2. 预加载关联数据
        query = query.options(
            selectinload(BackTestResult.strategy)
        )

        # 3. 获取总数
        count_query = select(func.count()).select_from(query.subquery())
        total = await self.db.scalar(count_query)

        # 4. 分页查询
        offset = (page - 1) * per_page
        query = query.offset(offset).limit(per_page)

        # 5. 执行查询
        results = await self.db.execute(query)
        items = results.scalars().all()

        return PaginatedResult(
            items=items,
            total=total,
            page=page,
            per_page=per_page,
            total_pages=(total + per_page - 1) // per_page
        )

    async def bulk_insert_results(self, results: List[BackTestResult]):
        """批量插入优化"""
        # 使用 bulk_insert_mappings 提高性能
        await self.db.execute(
            insert(BackTestResult),
            [
                {
                    'task_id': r.task_id,
                    'symbol': r.symbol,
                    'pnl_ratio': r.pnl_ratio,
                    # ... 其他字段
                }
                for r in results
            ]
        )
        await self.db.commit()

    async def get_performance_metrics(self, strategy_id: int):
        """聚合查询优化"""
        query = select(
            func.avg(BackTestResult.pnl_ratio).label('avg_pnl'),
            func.stddev(BackTestResult.pnl_ratio).label('std_pnl'),
            func.max(BackTestResult.pnl_ratio).label('max_pnl'),
            func.min(BackTestResult.pnl_ratio).label('min_pnl'),
            func.count(BackTestResult.id).label('total_count')
        ).where(
            BackTestResult.strategy_id == strategy_id
        )

        result = await self.db.execute(query)
        return result.first()
```

#### 6.2.2 缓存策略

```python
# Redis缓存层
class CacheLayer:
    def __init__(self, redis_client: Redis):
        self.redis = redis_client

    async def get_or_set(
        self,
        key: str,
        fetch_func: Callable,
        expire_time: int = 300
    ):
        """缓存模式：先查缓存，缓存不存在则调用函数获取"""
        # 尝试从缓存获取
        cached = await self.redis.get(key)
        if cached:
            return json.loads(cached)

        # 缓存不存在，调用函数获取
        data = await fetch_func()

        # 存储到缓存
        await self.redis.setex(
            key,
            expire_time,
            json.dumps(data, default=str)
        )

        return data

    async def invalidate_pattern(self, pattern: str):
        """批量删除缓存"""
        keys = await self.redis.keys(pattern)
        if keys:
            await self.redis.delete(*keys)

# 缓存装饰器
def cached(expire_time: int = 300, key_prefix: str = ""):
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # 生成缓存键
            key = f"{key_prefix}:{func.__name__}:{hash(str(args) + str(kwargs))}"

            # 尝试从缓存获取
            cached_result = await cache.redis.get(key)
            if cached_result:
                return json.loads(cached_result)

            # 执行函数
            result = await func(*args, **kwargs)

            # 存储到缓存
            await cache.redis.setex(key, expire_time, json.dumps(result, default=str))

            return result
        return wrapper
    return decorator

# 使用缓存
class StrategyService:
    @cached(expire_time=600, key_prefix="strategy")
    async def get_strategy_performance(self, strategy_id: int):
        """获取策略性能数据（缓存10分钟）"""
        # 计算性能指标
        metrics = await self.repository.get_performance_metrics(strategy_id)
        return metrics
```

#### 6.2.3 异步处理

```python
# 异步任务处理
import asyncio
from concurrent.futures import ThreadPoolExecutor

class AsyncProcessor:
    def __init__(self, max_workers: int = 10):
        self.thread_pool = ThreadPoolExecutor(max_workers=max_workers)

    async def process_batch_backtests(self, tasks: List[BacktestTask]):
        """批量处理回测任务"""
        # 创建任务协程
        coroutines = [
            self.process_single_backtest(task)
            for task in tasks
        ]

        # 并发执行
        results = await asyncio.gather(*coroutines, return_exceptions=True)

        # 处理结果
        successful = []
        failed = []

        for i, result in enumerate(results):
            if isinstance(result, Exception):
                failed.append({
                    'task': tasks[i],
                    'error': str(result)
                })
            else:
                successful.append(result)

        return {'successful': successful, 'failed': failed}

    async def process_single_backtest(self, task: BacktestTask):
        """处理单个回测任务"""
        # 在线程池中执行CPU密集型任务
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(
            self.thread_pool,
            self._execute_backtest_sync,
            task
        )

    def _execute_backtest_sync(self, task: BacktestTask):
        """同步执行回测（CPU密集型）"""
        # 创建回测引擎
        engine = BacktestEngine()

        # 执行回测
        result = engine.run_backtest(task.config)

        return result

# 异步数据采集
class AsyncDataCollector:
    async def collect_market_data(
        self,
        symbols: List[str],
        start_date: datetime,
        end_date: datetime
    ):
        """异步采集市场数据"""
        # 创建信号量限制并发数
        semaphore = asyncio.Semaphore(10)

        async def fetch_single_symbol(symbol: str):
            async with semaphore:
                # 获取单个股票数据
                data = await self.fetch_symbol_data(symbol, start_date, end_date)
                return symbol, data

        # 并发获取所有股票数据
        results = await asyncio.gather(
            *[fetch_single_symbol(symbol) for symbol in symbols],
            return_exceptions=True
        )

        # 处理结果
        return {
            symbol: data
            for symbol, data in results
            if not isinstance(data, Exception)
        }
```

### 6.3 监控与调优

#### 6.3.1 性能监控

```python
# 性能监控装饰器
import time
import functools
from prometheus_client import Counter, Histogram, Gauge

# 指标定义
REQUEST_COUNT = Counter(
    'http_requests_total',
    'Total HTTP requests',
    ['method', 'endpoint', 'status']
)

REQUEST_DURATION = Histogram(
    'http_request_duration_seconds',
    'HTTP request duration'
)

ACTIVE_CONNECTIONS = Gauge(
    'websocket_connections_active',
    'Active WebSocket connections'
)

def monitor_performance(func):
    """性能监控装饰器"""
    @functools.wraps(func)
    async def wrapper(*args, **kwargs):
        # 记录开始时间
        start_time = time.time()

        # 记录请求
        REQUEST_COUNT.labels(
            method='GET',
            endpoint=func.__name__,
            status='success'
        ).inc()

        try:
            # 执行函数
            result = await func(*args, **kwargs)
            return result
        finally:
            # 记录执行时间
            duration = time.time() - start_time
            REQUEST_DURATION.observe(duration)

    return wrapper

# 使用
@monitor_performance
async def get_backtest_results(filters: dict):
    """获取回测结果"""
    results = await repository.get_results(filters)
    return results
```

#### 6.3.2 慢查询分析

```python
# 慢查询日志
import logging
from functools import wraps

slow_query_logger = logging.getLogger('slow_query')

def log_slow_query(threshold: float = 1.0):
    """慢查询日志装饰器"""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            start_time = time.time()

            result = await func(*args, **kwargs)

            duration = time.time() - start_time

            if duration > threshold:
                slow_query_logger.warning(
                    f"Slow query detected: {func.__name__} took {duration:.2f}s",
                    extra={
                        'function': func.__name__,
                        'duration': duration,
                        'args': str(args),
                        'kwargs': str(kwargs)
                    }
                )

            return result
        return wrapper
    return decorator

# 使用
@log_slow_query(threshold=0.5)
async def get_market_data(symbol: str, timeframe: str):
    """获取市场数据"""
    # 查询逻辑
    pass
```

---

## 7. 安全设计

### 7.1 身份认证与授权

#### 7.1.1 JWT认证机制

```python
from jose import JWTError, jwt
from datetime import datetime, timedelta
from passlib.context import CryptContext

# 密码加密
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

class AuthService:
    def __init__(self, secret_key: str, algorithm: str = "HS256"):
        self.secret_key = secret_key
        self.algorithm = algorithm
        self.access_token_expire_minutes = 30

    def create_access_token(self, data: dict):
        """创建访问令牌"""
        to_encode = data.copy()
        expire = datetime.utcnow() + timedelta(minutes=self.access_token_expire_minutes)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, self.secret_key, algorithm=self.algorithm)
        return encoded_jwt

    def verify_token(self, token: str):
        """验证令牌"""
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
            user_id: str = payload.get("sub")
            if user_id is None:
                return None
            return user_id
        except JWTError:
            return None

    def hash_password(self, password: str) -> str:
        """哈希密码"""
        return pwd_context.hash(password)

    def verify_password(self, plain_password: str, hashed_password: str) -> bool:
        """验证密码"""
        return pwd_context.verify(plain_password, hashed_password)

# FastAPI依赖
async def get_current_user(token: str = Depends(oauth2_scheme)):
    """获取当前用户"""
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )

    user_id = auth_service.verify_token(token)
    if user_id is None:
        raise credentials_exception

    user = await UserRepository.get_by_id(user_id)
    if user is None:
        raise credentials_exception

    return user
```

#### 7.1.2 RBAC权限控制

```python
from enum import Enum
from typing import List, Set

class Permission(Enum):
    # 用户管理
    USER_CREATE = "user:create"
    USER_READ = "user:read"
    USER_UPDATE = "user:update"
    USER_DELETE = "user:delete"

    # 策略管理
    STRATEGY_CREATE = "strategy:create"
    STRATEGY_READ = "strategy:read"
    STRATEGY_UPDATE = "strategy:update"
    STRATEGY_DELETE = "strategy:delete"

    # 回测管理
    BACKTEST_CREATE = "backtest:create"
    BACKTEST_READ = "backtest:read"
    BACKTEST_DELETE = "backtest:delete"

    # 交易操作
    TRADE_EXECUTE = "trade:execute"

class Role(Enum):
    ADMIN = "admin"
    QUANT_TRADER = "quant_trader"
    TRADER = "trader"
    VIEWER = "viewer"

# 角色权限映射
ROLE_PERMISSIONS = {
    Role.ADMIN: {
        *Permission.USER_CREATE,
        *Permission.USER_READ,
        *Permission.USER_UPDATE,
        *Permission.USER_DELETE,
        *Permission.STRATEGY_CREATE,
        *Permission.STRATEGY_READ,
        *Permission.STRATEGY_UPDATE,
        *Permission.STRATEGY_DELETE,
        *Permission.BACKTEST_CREATE,
        *Permission.BACKTEST_READ,
        *Permission.BACKTEST_DELETE,
        *Permission.TRADE_EXECUTE,
    },
    Role.QUANT_TRADER: {
        Permission.STRATEGY_CREATE,
        Permission.STRATEGY_READ,
        Permission.STRATEGY_UPDATE,
        Permission.STRATEGY_DELETE,
        Permission.BACKTEST_CREATE,
        Permission.BACKTEST_READ,
        Permission.BACKTEST_DELETE,
        Permission.TRADE_EXECUTE,
    },
    Role.TRADER: {
        Permission.STRATEGY_READ,
        Permission.BACKTEST_CREATE,
        Permission.BACKTEST_READ,
        Permission.TRADE_EXECUTE,
    },
    Role.VIEWER: {
        Permission.STRATEGY_READ,
        Permission.BACKTEST_READ,
    },
}

class PermissionChecker:
    """权限检查器"""
    def __init__(self, required_permission: Permission):
        self.required_permission = required_permission

    async def __call__(self, current_user: User):
        """检查用户权限"""
        user_role = Role(current_user.role)
        user_permissions = ROLE_PERMISSIONS.get(user_role, set())

        if self.required_permission not in user_permissions:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Permission denied: {self.required_permission.value}"
            )

        return True

# 使用依赖
@router.post("/backtest", dependencies=[Depends(PermissionChecker(Permission.BACKTEST_CREATE))])
async def create_backtest(config: BacktestConfig, current_user: User = Depends(get_current_user)):
    """创建回测任务"""
    # 创建逻辑
    pass
```

### 7.2 API安全

#### 7.2.1 请求限流

```python
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

# 创建限流器
limiter = Limiter(key_func=get_remote_address)

# 全局限流配置
limiter = Limiter(
    key_func=get_remote_address,
    default_limits=["200 per day", "50 per hour"]
)

@app.post("/api/backtest/start")
@limiter.limit("10 per minute")  # 每分钟最多10次
async def create_backtest(
    request: Request,
    config: BacktestConfig,
    current_user: User = Depends(get_current_user)
):
    """创建回测任务"""
    # 业务逻辑
    pass

# 自定义限流键函数
def get_user_id_key(request: Request):
    """基于用户ID限流"""
    return request.state.user.id if hasattr(request.state, 'user') else get_remote_address(request)

@app.get("/api/strategies")
@limiter.limit("100 per hour", key_func=get_user_id_key)
async def get_strategies(request: Request):
    """获取策略列表"""
    # 业务逻辑
    pass
```

#### 7.2.2 输入验证

```python
from pydantic import BaseModel, validator, Field
from typing import Optional
import re

class BacktestConfig(BaseModel):
    """回测配置验证"""
    strategy: str = Field(..., min_length=1, max_length=50)
    symbols: List[str] = Field(..., min_items=1, max_items=1000)
    start_time: datetime
    end_time: datetime

    @validator('strategy')
    def validate_strategy(cls, v):
        # 验证策略名称格式
        if not re.match(r'^[a-zA-Z0-9_]+$', v):
            raise ValueError('策略名称只能包含字母、数字和下划线')
        return v

    @validator('symbols')
    def validate_symbols(cls, v):
        # 验证股票代码格式
        for symbol in v:
            if not re.match(r'^[A-Z]{2,4}\.\d{6}$', symbol):
                raise ValueError(f'无效的股票代码格式: {symbol}')
        return v

    @validator('end_time')
    def validate_time_range(cls, end_time, values):
        # 验证时间范围
        start_time = values.get('start_time')
        if start_time and end_time <= start_time:
            raise ValueError('结束时间必须大于开始时间')

        # 限制回测时间范围不超过1年
        time_diff = end_time - start_time
        if time_diff.days > 365:
            raise ValueError('回测时间范围不能超过1年')

        return end_time

# SQL注入防护
class SafeQueryBuilder:
    """安全的查询构建器"""
    def __init__(self):
        self.conditions = []
        self.params = []

    def add_condition(self, field: str, operator: str, value: any):
        """添加查询条件"""
        # 验证字段名（防止SQL注入）
        if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', field):
            raise ValueError(f'Invalid field name: {field}')

        # 验证操作符
        allowed_operators = ['=', '!=', '>', '<', '>=', '<=', 'IN', 'LIKE']
        if operator not in allowed_operators:
            raise ValueError(f'Invalid operator: {operator}')

        if operator == 'IN':
            self.conditions.append(f"{field} IN ({','.join(['%s'] * len(value))})")
            self.params.extend(value)
        else:
            self.conditions.append(f"{field} {operator} %s")
            self.params.append(value)

    def build(self) -> tuple:
        """构建查询"""
        where_clause = " AND ".join(self.conditions) if self.conditions else "1=1"
        return where_clause, self.params
```

#### 7.2.3 敏感数据处理

```python
import hashlib
from cryptography.fernet import Fernet

class DataProtection:
    """数据保护工具"""
    def __init__(self, encryption_key: bytes):
        self.cipher = Fernet(encryption_key)

    def encrypt_sensitive_data(self, data: str) -> str:
        """加密敏感数据"""
        return self.cipher.encrypt(data.encode()).decode()

    def decrypt_sensitive_data(self, encrypted_data: str) -> str:
        """解密敏感数据"""
        return self.cipher.decrypt(encrypted_data.encode()).decode()

    def hash_sensitive_data(self, data: str) -> str:
        """哈希敏感数据（不可逆）"""
        return hashlib.sha256(data.encode()).hexdigest()

    def mask_sensitive_data(self, data: str, visible_chars: int = 4) -> str:
        """脱敏显示"""
        if len(data) <= visible_chars * 2:
            return '*' * len(data)

        return data[:visible_chars] + '*' * (len(data) - visible_chars * 2) + data[-visible_chars:]

# 敏感数据字段
class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    email = Column(String(255), unique=True, nullable=False)
    password_hash = Column(String(255), nullable=False)  # 只存储哈希值
    api_key_hash = Column(String(255), nullable=False)  # API密钥哈希
    phone_masked = Column(String(20))  # 脱敏手机号

    # 不存储原始密码，只存储哈希值
    # 使用bcrypt进行密码哈希
```

### 7.3 数据安全

#### 7.3.1 数据传输加密

```python
# HTTPS强制跳转
from fastapi.middleware.httpsredirect import HTTPSRedirectMiddleware

app.add_middleware(HTTPSRedirectMiddleware)

# TLS配置
uvicorn.run(
    "main:app",
    host="0.0.0.0",
    port=443,
    ssl_keyfile="path/to/key.pem",
    ssl_certfile="path/to/cert.pem"
)

# WebSocket加密
@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    # 强制加密连接
    if websocket.headers.get("upgrade") != "websocket":
        await websocket.close()
        return

    await websocket.accept()
    # 处理WebSocket消息
```

#### 7.3.2 数据存储加密

```python
# 数据库连接加密
DATABASE_URL = "mysql+pymysql://user:pass@localhost/db?charset=utf8mb4"

# 字段级加密
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.ext.mutable import Mutable

class EncryptedColumn(Mutable):
    """加密列"""
    def __init__(self, encryption_func, decryption_func):
        self.encrypt = encryption_func
        self.decrypt = decryption_func

    def __setattr__(self, key, value):
        if key in ('encrypt', 'decrypt'):
            object.__setattr__(self, key, value)
        else:
            object.__setattr__(self, key, value)

class BacktestResult(Base):
    __tablename__ = 'backtest_results'

    id = Column(Integer, primary_key=True)
    _pnl_ratio = Column(String(255))  # 加密存储

    @hybrid_property
    def pnl_ratio(self):
        """解密读取"""
        if self._pnl_ratio:
            return self.cipher.decrypt(self._pnl_ratio.encode())
        return None

    @pnl_ratio.setter
    def pnl_ratio(self, value):
        """加密存储"""
        if value is not None:
            self._pnl_ratio = self.cipher.encrypt(str(value).encode()).decode()
        else:
            self._pnl_ratio = None
```

### 7.4 审计日志

```python
import json
from datetime import datetime

class AuditLogger:
    """审计日志记录器"""
    def __init__(self, db_session):
        self.db = db_session

    def log_user_action(
        self,
        user_id: int,
        action: str,
        resource: str,
        resource_id: str = None,
        details: dict = None,
        ip_address: str = None
    ):
        """记录用户操作"""
        audit_log = AuditLog(
            user_id=user_id,
            action=action,
            resource=resource,
            resource_id=resource_id,
            details=json.dumps(details) if details else None,
            ip_address=ip_address,
            timestamp=datetime.utcnow()
        )
        self.db.add(audit_log)
        self.db.commit()

    def log_security_event(
        self,
        event_type: str,
        severity: str,
        description: str,
        user_id: int = None,
        ip_address: str = None
    ):
        """记录安全事件"""
        security_event = SecurityLog(
            event_type=event_type,
            severity=severity,
            description=description,
            user_id=user_id,
            ip_address=ip_address,
            timestamp=datetime.utcnow()
        )
        self.db.add(security_event)
        self.db.commit()

# 使用审计日志
@router.post("/api/strategies")
async def create_strategy(
    strategy: StrategyCreate,
    current_user: User = Depends(get_current_user)
):
    """创建策略"""
    try:
        # 业务逻辑
        new_strategy = await StrategyService.create(strategy, current_user.id)

        # 记录审计日志
        audit_logger.log_user_action(
            user_id=current_user.id,
            action="CREATE",
            resource="STRATEGY",
            resource_id=str(new_strategy.id),
            details={"strategy_name": strategy.name}
        )

        return new_strategy

    except Exception as e:
        # 记录安全事件
        audit_logger.log_security_event(
            event_type="STRATEGY_CREATE_FAILED",
            severity="WARNING",
            description=str(e),
            user_id=current_user.id
        )
        raise
```

---

## 8. 数据架构

### 8.1 数据模型设计

#### 8.1.1 核心实体关系图

```mermaid
erDiagram
    USERS ||--o{ BACKTEST_TASKS : creates
    USERS ||--o{ STRATEGIES : owns
    STRATEGIES ||--o{ BACKTEST_TASKS : used_in
    STRATEGIES ||--o{ STRATEGY_PERFORMANCES : tracks
    BACKTEST_TASKS ||--o{ BACKTEST_RESULTS : produces
    BACKTEST_TASKS ||--o{ TRADES : generates
    STOCK_SYMBOLS ||--o{ BACKTEST_RESULTS : analyzed
    STOCK_SYMBOLS ||--o{ TRADES : traded

    USERS {
        int id PK
        string email UK
        string password_hash
        string role
        datetime created_at
        datetime updated_at
    }

    STRATEGIES {
        int id PK
        string name UK
        string display_name
        text description
        string strategy_type
        json parameters
        boolean is_active
        int user_id FK
        datetime created_at
        datetime updated_at
    }

    BACKTEST_TASKS {
        int id PK
        string task_id UK
        int strategy_id FK
        json symbols
        datetime start_time
        datetime end_time
        string status
        int progress
        json parameters
        json result_summary
        text error_message
        datetime created_at
        datetime updated_at
    }

    BACKTEST_RESULTS {
        int id PK
        string task_id FK
        int strategy_id FK
        string symbol
        string name
        string strategy_name
        datetime backtest_start_time
        datetime backtest_end_time
        decimal pnl_ratio
        decimal sharp_ratio
        decimal max_drawdown
        int open_count
        int close_count
        int win_count
        int lose_count
        decimal win_ratio
        datetime created_at
    }

    TRADES {
        int id PK
        string task_id FK
        string symbol
        string side
        decimal price
        int quantity
        decimal amount
        decimal fee
        datetime timestamp
        string strategy_name
        datetime created_at
    }

    STOCK_SYMBOLS {
        int id PK
        string symbol UK
        string name
        string market
        string industry
        boolean is_active
        datetime created_at
        datetime updated_at
    }
```

#### 8.1.2 时序数据模型

```python
# 时序数据存储（InfluxDB）
class TimeSeriesData:
    """时序数据模型"""
    measurement = "market_data"

    tags = [
        "symbol",
        "market"
    ]

    fields = [
        "open",
        "high",
        "low",
        "close",
        "volume",
        "amount"
    ]

# InfluxDB数据写入
from influxdb_client import InfluxDBClient, Point
from influxdb_client.client.write_api import ASYNCHRONOUS

class InfluxDBService:
    def __init__(self, url: str, token: str, org: str):
        self.client = InfluxDBClient(url=url, token=token, org=org)
        self.write_api = self.client.write_api(write_options=ASYNCHRONOUS)
        self.query_api = self.client.query_api()

    async def write_market_data(self, symbol: str, market_data: dict):
        """写入市场数据"""
        point = Point("market_data") \
            .tag("symbol", symbol) \
            .field("open", market_data['open']) \
            .field("high", market_data['high']) \
            .field("low", market_data['low']) \
            .field("close", market_data['close']) \
            .field("volume", market_data['volume']) \
            .field("amount", market_data['amount']) \
            .time(market_data['timestamp'])

        self.write_api.write(bucket="trading_data", record=point)

    async def query_price_history(
        self,
        symbol: str,
        start_time: str,
        end_time: str,
        aggregation_window: str = "1h"
    ):
        """查询价格历史"""
        query = f"""
        from(bucket: "trading_data")
        |> range(start: {start_time}, stop: {end_time})
        |> filter(fn: (r) => r._measurement == "market_data" and r.symbol == "{symbol}")
        |> aggregateWindow(every: {aggregation_window}, fn: mean, createEmpty: false)
        |> yield(name: "mean")
        """

        result = self.query_api.query(query)
        return result
```

### 8.2 数据采集架构

#### 8.2.1 数据源适配器

```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any

class DataSourceAdapter(ABC):
    """数据源适配器基类"""
    @abstractmethod
    async def fetch_market_data(
        self,
        symbols: List[str],
        start_date: str,
        end_date: str
    ) -> List[Dict[str, Any]]:
        """获取市场数据"""
        pass

    @abstractmethod
    async def fetch_real_time_quote(self, symbol: str) -> Dict[str, Any]:
        """获取实时行情"""
        pass

class GMIDataSourceAdapter(DataSourceAdapter):
    """GMI数据源适配器"""
    def __init__(self, token: str):
        self.token = token
        set_token(token)

    async def fetch_market_data(
        self,
        symbols: List[str],
        start_date: str,
        end_date: str
    ) -> List[Dict[str, Any]]:
        """从GMI获取历史数据"""
        data = []
        for symbol in symbols:
            # 获取历史K线数据
            df = stk_get_history(
                symbol=symbol,
                start_date=start_date,
                end_date=end_date,
                fields=['bob', 'open', 'high', 'low', 'close', 'volume', 'amount']
            )

            # 转换为标准格式
            for _, row in df.iterrows():
                data.append({
                    'symbol': symbol,
                    'timestamp': row['bob'],
                    'open': row['open'],
                    'high': row['high'],
                    'low': row['low'],
                    'close': row['close'],
                    'volume': row['volume'],
                    'amount': row['amount']
                })

        return data

    async def fetch_real_time_quote(self, symbol: str) -> Dict[str, Any]:
        """从GMI获取实时行情"""
        quote = stk_get_latest_quote(symbol)
        return {
            'symbol': symbol,
            'price': quote['last'],
            'change': quote['change'],
            'change_percent': quote['pct_chg'],
            'volume': quote['volume'],
            'timestamp': datetime.now()
        }

class DataSourceManager:
    """数据源管理器"""
    def __init__(self):
        self.adapters: Dict[str, DataSourceAdapter] = {}
        self.register_default_adapters()

    def register_default_adapters(self):
        """注册默认适配器"""
        self.adapters['gmi'] = GMIDataSourceAdapter(os.getenv('GMI_TOKEN'))

    def get_adapter(self, source: str) -> DataSourceAdapter:
        """获取数据源适配器"""
        if source not in self.adapters:
            raise ValueError(f"Unsupported data source: {source}")
        return self.adapters[source]

    async def get_market_data(
        self,
        source: str,
        symbols: List[str],
        start_date: str,
        end_date: str
    ) -> List[Dict[str, Any]]:
        """获取市场数据"""
        adapter = self.get_adapter(source)
        return await adapter.fetch_market_data(symbols, start_date, end_date)
```

#### 8.2.2 数据清洗管道

```python
from typing import List, Dict, Any
import pandas as pd
import numpy as np

class DataCleaner:
    """数据清洗器"""
    def __init__(self):
        self.rules = [
            self.remove_duplicates,
            self.handle_missing_values,
            self.remove_outliers,
            self.validate_data_range,
            self.normalize_data
        ]

    async def clean(self, data: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """执行数据清洗"""
        df = pd.DataFrame(data)

        for rule in self.rules:
            df = rule(df)

        return df.to_dict('records')

    def remove_duplicates(self, df: pd.DataFrame) -> pd.DataFrame:
        """去除重复数据"""
        return df.drop_duplicates(subset=['symbol', 'timestamp'])

    def handle_missing_values(self, df: pd.DataFrame) -> pd.DataFrame:
        """处理缺失值"""
        # 数值字段使用前值填充
        numeric_columns = ['open', 'high', 'low', 'close', 'volume']
        df[numeric_columns] = df[numeric_columns].fillna(method='ffill')

        # 删除完全缺失的行
        return df.dropna(subset=numeric_columns)

    def remove_outliers(self, df: pd.DataFrame) -> pd.DataFrame:
        """去除异常值"""
        # 使用3σ原则去除异常值
        numeric_columns = ['open', 'high', 'low', 'close', 'volume']

        for col in numeric_columns:
            mean = df[col].mean()
            std = df[col].std()
            lower_bound = mean - 3 * std
            upper_bound = mean + 3 * std

            df = df[(df[col] >= lower_bound) & (df[col] <= upper_bound)]

        return df

    def validate_data_range(self, df: pd.DataFrame) -> pd.DataFrame:
        """验证数据范围"""
        # 验证价格合理性
        df = df[(df['open'] > 0) & (df['high'] > 0) & (df['low'] > 0) & (df['close'] > 0)]

        # 验证OHLC逻辑关系
        df = df[
            (df['high'] >= df['open']) &
            (df['high'] >= df['close']) &
            (df['low'] <= df['open']) &
            (df['low'] <= df['close'])
        ]

        return df

    def normalize_data(self, df: pd.DataFrame) -> pd.DataFrame:
        """数据标准化"""
        # 确保时间戳格式一致
        df['timestamp'] = pd.to_datetime(df['timestamp'])

        # 确保数值类型正确
        numeric_columns = ['open', 'high', 'low', 'close', 'volume']
        df[numeric_columns] = df[numeric_columns].astype(float)

        # 按时间排序
        return df.sort_values('timestamp').reset_index(drop=True)

class DataQualityChecker:
    """数据质量检查"""
    def __init__(self):
        self.thresholds = {
            'missing_ratio': 0.05,  # 缺失率阈值5%
            'duplicate_ratio': 0.01,  # 重复率阈值1%
            'outlier_ratio': 0.02  # 异常值比例阈值2%
        }

    async def check_quality(self, data: List[Dict[str, Any]]) -> Dict[str, Any]:
        """检查数据质量"""
        df = pd.DataFrame(data)
        report = {
            'total_records': len(df),
            'missing_values': {},
            'duplicate_count': 0,
            'outlier_count': {},
            'quality_score': 100.0
        }

        # 检查缺失值
        for col in df.columns:
            missing_count = df[col].isna().sum()
            missing_ratio = missing_count / len(df)
            report['missing_values'][col] = {
                'count': missing_count,
                'ratio': missing_ratio
            }

            if missing_ratio > self.thresholds['missing_ratio']:
                report['quality_score'] -= 10

        # 检查重复值
        duplicate_count = df.duplicated().sum()
        report['duplicate_count'] = duplicate_count
        duplicate_ratio = duplicate_count / len(df)

        if duplicate_ratio > self.thresholds['duplicate_ratio']:
            report['quality_score'] -= 15

        # 检查异常值
        numeric_columns = ['open', 'high', 'low', 'close', 'volume']
        for col in numeric_columns:
            if col in df.columns:
                Q1 = df[col].quantile(0.25)
                Q3 = df[col].quantile(0.75)
                IQR = Q3 - Q1
                lower_bound = Q1 - 1.5 * IQR
                upper_bound = Q3 + 1.5 * IQR

                outlier_count = ((df[col] < lower_bound) | (df[col] > upper_bound)).sum()
                report['outlier_count'][col] = outlier_count

                outlier_ratio = outlier_count / len(df)
                if outlier_ratio > self.thresholds['outlier_ratio']:
                    report['quality_score'] -= 5

        return report
```

### 8.3 数据同步机制

#### 8.3.1 实时数据同步

```python
import asyncio
from datetime import datetime

class RealTimeDataSync:
    """实时数据同步"""
    def __init__(self, data_source: DataSourceAdapter, storage: DataStorage):
        self.data_source = data_source
        self.storage = storage
        self.is_running = False
        self.task = None

    async def start(self):
        """启动同步"""
        self.is_running = True
        self.task = asyncio.create_task(self._sync_loop())

    async def stop(self):
        """停止同步"""
        self.is_running = False
        if self.task:
            self.task.cancel()
            await self.task

    async def _sync_loop(self):
        """同步循环"""
        while self.is_running:
            try:
                # 获取活跃股票列表
                active_symbols = await self.storage.get_active_symbols()

                # 并发获取实时行情
                tasks = [
                    self.data_source.fetch_real_time_quote(symbol)
                    for symbol in active_symbols
                ]

                quotes = await asyncio.gather(*tasks, return_exceptions=True)

                # 存储有效数据
                for quote in quotes:
                    if isinstance(quote, dict):
                        await self.storage.save_realtime_quote(quote)

                # 等待下次同步（1秒间隔）
                await asyncio.sleep(1)

            except Exception as e:
                print(f"Sync error: {e}")
                await asyncio.sleep(5)  # 错误时延长间隔

class DataStorage:
    """数据存储抽象"""
    async def save_realtime_quote(self, quote: Dict[str, Any]):
        """存储实时行情"""
        # 存储到Redis（高速缓存）
        await redis_client.hset(
            f"quote:{quote['symbol']}",
            mapping={
                "price": quote['price'],
                "change": quote['change'],
                "volume": quote['volume'],
                "timestamp": quote['timestamp'].isoformat()
            }
        )

        # 设置过期时间（30秒）
        await redis_client.expire(f"quote:{quote['symbol']}", 30)

        # 发布到Redis频道（供WebSocket推送）
        await redis_client.publish(
            "market_data_updates",
            json.dumps(quote)
        )
```

#### 8.3.2 批量数据同步

```python
class BatchDataSync:
    """批量数据同步"""
    def __init__(self, data_source: DataSourceAdapter, storage: DataStorage):
        self.data_source = data_source
        self.storage = storage

    async def sync_historical_data(
        self,
        symbols: List[str],
        start_date: str,
        end_date: str
    ):
        """同步历史数据"""
        print(f"开始同步历史数据: {len(symbols)} 个股票")

        # 分批处理，避免内存溢出
        batch_size = 50
        for i in range(0, len(symbols), batch_size):
            batch_symbols = symbols[i:i + batch_size]
            print(f"处理批次 {i//batch_size + 1}, 股票: {len(batch_symbols)}")

            # 获取数据
            data = await self.data_source.fetch_market_data(
                batch_symbols, start_date, end_date
            )

            if data:
                # 清洗数据
                cleaned_data = await DataCleaner().clean(data)

                # 存储数据
                await self.storage.save_market_data_batch(cleaned_data)

                print(f"批次完成: 存储 {len(cleaned_data)} 条记录")

            # 批次间暂停
            await asyncio.sleep(1)

        print("历史数据同步完成")

    async def sync_index_constituents(self, index_symbol: str):
        """同步指数成分股"""
        print(f"同步指数成分股: {index_symbol}")

        # 获取指数成分股
        constituents = await self.data_source.get_index_constituents(index_symbol)

        # 更新股票池
        await self.storage.update_stock_pool(constituents)

        print(f"指数成分股同步完成: {len(constituents)} 只股票")

class IncrementalSync:
    """增量数据同步"""
    async def sync_daily_data(self, trade_date: str):
        """同步每日数据"""
        # 获取最后同步时间
        last_sync_time = await self.storage.get_last_sync_time('daily_data')

        if last_sync_time:
            start_date = last_sync_time.strftime('%Y-%m-%d')
        else:
            # 首次同步，从1个月前开始
            start_date = (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d')

        # 获取活跃股票列表
        active_symbols = await self.storage.get_active_symbols()

        # 获取增量数据
        data = await self.data_source.fetch_market_data(
            active_symbols,
            start_date,
            trade_date
        )

        # 只保留新增数据
        new_data = await self.storage.filter_new_data(data, 'daily_data')

        if new_data:
            # 清洗并存储
            cleaned_data = await DataCleaner().clean(new_data)
            await self.storage.save_market_data_batch(cleaned_data)

        # 更新同步时间
        await self.storage.update_last_sync_time('daily_data', trade_date)

        print(f"增量同步完成: 新增 {len(new_data) if new_data else 0} 条记录")
```

---

## 9. 部署架构

### 9.1 容器化部署

#### 9.1.1 Dockerfile配置

```dockerfile
# 多阶段构建 Python 后端
FROM python:3.9-slim as backend-builder

WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    && rm -rf /var/lib/apt/lists/*

# 复制依赖文件
COPY requirements.txt .

# 安装Python依赖
RUN pip install --no-cache-dir --user -r requirements.txt

# 复制应用代码
COPY src/ ./src/
COPY config/ ./config/

# 生产阶段
FROM python:3.9-slim as backend

WORKDIR /app

# 创建非root用户
RUN groupadd -r appuser && useradd -r -g appuser appuser

# 从构建阶段复制已安装的包
COPY --from=backend-builder /root/.local /home/appuser/.local

# 复制应用代码
COPY --from=backend-builder /app/src ./src
COPY --from=backend-builder /app/config ./config

# 设置环境变量
ENV PATH=/home/appuser/.local/bin:$PATH
ENV PYTHONPATH=/app/src

# 切换到非root用户
USER appuser

# 暴露端口
EXPOSE 8000

# 健康检查
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8000/api/health || exit 1

# 启动命令
CMD ["uvicorn", "src.pytrading.api.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

```dockerfile
# 前端构建
FROM node:18-alpine as frontend-builder

WORKDIR /app

# 安装依赖
COPY xTrading/package*.json ./
RUN npm ci --only=production

# 复制源代码
COPY xTrading/ .

# 构建应用
RUN npm run build

# 生产阶段
FROM nginx:alpine as frontend

# 复制构建结果
COPY --from=frontend-builder /app/dist /usr/share/nginx/html

# 复制nginx配置
COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

#### 9.1.2 Docker Compose配置

```yaml
# docker-compose.yml
version: '3.8'

services:
  # MySQL数据库
  mysql:
    image: mysql:8.0
    container_name: pytrading-mysql
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: ${MYSQL_DATABASE}
      MYSQL_USER: ${MYSQL_USER}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}
    volumes:
      - mysql_data:/var/lib/mysql
      - ./docker/mysql/init:/docker-entrypoint-initdb.d
    ports:
      - "3306:3306"
    command: --default-authentication-plugin=mysql_native_password
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      interval: 30s
      timeout: 10s
      retries: 5

  # Redis缓存
  redis:
    image: redis:7-alpine
    container_name: pytrading-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    command: redis-server --appendonly yes
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3

  # RabbitMQ消息队列
  rabbitmq:
    image: rabbitmq:3-management
    container_name: pytrading-rabbitmq
    environment:
      RABBITMQ_DEFAULT_USER: ${RABBITMQ_USER}
      RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASSWORD}
    ports:
      - "5672:5672"
      - "15672:15672"
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq

  # Python后端API
  backend:
    build:
      context: .
      dockerfile: Dockerfile.backend
    container_name: pytrading-backend
    environment:
      - DATABASE_URL=mysql+pymysql://${MYSQL_USER}:${MYSQL_PASSWORD}@mysql:3306/${MYSQL_DATABASE}
      - REDIS_URL=redis://redis:6379/0
      - RABBITMQ_URL=amqp://${RABBITMQ_USER}:${RABBITMQ_PASSWORD}@rabbitmq:5672/
      - SECRET_KEY=${SECRET_KEY}
    ports:
      - "8000:8000"
    depends_on:
      mysql:
        condition: service_healthy
      redis:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  # 前端Web
  frontend:
    build:
      context: .
      dockerfile: Dockerfile.frontend
    container_name: pytrading-frontend
    ports:
      - "80:80"
    depends_on:
      - backend
    restart: unless-stopped

  # Nginx反向代理
  nginx:
    image: nginx:alpine
    container_name: pytrading-nginx
    ports:
      - "443:443"
    volumes:
      - ./docker/nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./docker/nginx/ssl:/etc/nginx/ssl
    depends_on:
      - frontend
      - backend
    restart: unless-stopped

volumes:
  mysql_data:
  redis_data:
  rabbitmq_data:

networks:
  default:
    name: pytrading-network
```

### 9.2 Kubernetes部署

#### 9.2.1 部署清单

```yaml
# k8s/namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: pytrading
---
# k8s/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: pytrading-config
  namespace: pytrading
data:
  DATABASE_URL: "mysql+pymysql://user:pass@mysql-service:3306/pytrading"
  REDIS_URL: "redis://redis-service:6379/0"
  RABBITMQ_URL: "amqp://user:pass@rabbitmq-service:5672/"
---
# k8s/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: pytrading-secrets
  namespace: pytrading
type: Opaque
stringData:
  SECRET_KEY: "your-secret-key-here"
  MYSQL_ROOT_PASSWORD: "mysql-root-password"
  RABBITMQ_PASSWORD: "rabbitmq-password"
---
# k8s/mysql-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
  namespace: pytrading
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
        - name: mysql
          image: mysql:8.0
          env:
            - name: MYSQL_ROOT_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: pytrading-secrets
                  key: MYSQL_ROOT_PASSWORD
            - name: MYSQL_DATABASE
              value: pytrading
          ports:
            - containerPort: 3306
          volumeMounts:
            - name: mysql-storage
              mountPath: /var/lib/mysql
          resources:
            requests:
              memory: "1Gi"
              cpu: "500m"
            limits:
              memory: "2Gi"
              cpu: "1000m"
      volumes:
        - name: mysql-storage
          persistentVolumeClaim:
            claimName: mysql-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: mysql-service
  namespace: pytrading
spec:
  selector:
    app: mysql
  ports:
    - port: 3306
      targetPort: 3306
  type: ClusterIP
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
  namespace: pytrading
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
---
# k8s/backend-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: pytrading
spec:
  replicas: 3
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
        - name: backend
          image: pytrading/backend:latest
          env:
            - name: DATABASE_URL
              valueFrom:
                configMapKeyRef:
                  name: pytrading-config
                  key: DATABASE_URL
            - name: REDIS_URL
              valueFrom:
                configMapKeyRef:
                  name: pytrading-config
                  key: REDIS_URL
          ports:
            - containerPort: 8000
          readinessProbe:
            httpGet:
              path: /api/health
              port: 8000
            initialDelaySeconds: 10
            periodSeconds: 5
          livenessProbe:
            httpGet:
              path: /api/health
              port: 8000
            initialDelaySeconds: 30
            periodSeconds: 10
          resources:
            requests:
              memory: "512Mi"
              cpu: "250m"
            limits:
              memory: "1Gi"
              cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: backend-service
  namespace: pytrading
spec:
  selector:
    app: backend
  ports:
    - port: 8000
      targetPort: 8000
  type: ClusterIP
---
# k8s/frontend-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  namespace: pytrading
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
        - name: frontend
          image: pytrading/frontend:latest
          ports:
            - containerPort: 80
          resources:
            requests:
              memory: "128Mi"
              cpu: "100m"
            limits:
              memory: "256Mi"
              cpu: "200m"
---
apiVersion: v1
kind: Service
metadata:
  name: frontend-service
  namespace: pytrading
spec:
  selector:
    app: frontend
  ports:
    - port: 80
      targetPort: 80
  type: ClusterIP
---
# k8s/ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: pytrading-ingress
  namespace: pytrading
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/rate-limit: "100"
spec:
  tls:
    - hosts:
        - api.pytrading.com
        - app.pytrading.com
      secretName: pytrading-tls
  rules:
    - host: api.pytrading.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: backend-service
                port:
                  number: 8000
    - host: app.pytrading.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: frontend-service
                port:
                  number: 80
```

#### 9.2.2 Helm Chart

```yaml
# helm/pytrading/Chart.yaml
apiVersion: v2
name: pytrading
description: xTrading量化交易系统
type: application
version: 2.0.0
appVersion: "2.0.0"

# helm/pytrading/values.yaml
replicaCount: 3

image:
  repository: pytrading/backend
  tag: "2.0.0"
  pullPolicy: IfNotPresent

service:
  type: ClusterIP
  port: 80

ingress:
  enabled: true
  className: nginx
  hosts:
    - host: api.pytrading.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: pytrading-tls
      hosts:
        - api.pytrading.com

resources:
  limits:
    cpu: 500m
    memory: 1Gi
  requests:
    cpu: 250m
    memory: 512Mi

autoscaling:
  enabled: true
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70

mysql:
  auth:
    rootPassword: "mysql-root-password"
    database: "pytrading"
  primary:
    persistence:
      enabled: true
      size: 20Gi

redis:
  auth:
    enabled: true
    password: "redis-password"
  master:
    persistence:
      enabled: true
      size: 10Gi

rabbitmq:
  auth:
    username: "admin"
    password: "rabbitmq-password"
  persistence:
    enabled: true
    size: 10Gi
```

### 9.3 CI/CD流水线

#### 9.3.1 GitHub Actions

```yaml
# .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov

      - name: Run tests
        run: |
          pytest tests/ --cov=src/pytrading --cov-report=xml

      - name: Upload coverage
        uses: codecov/codecov-action@v3

  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Log in to Container Registry
        uses: docker/login-action@f4ef658c0e316de2ce7986f6df7f1a7b0c29b81
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfdfcb9b3e14e6feb70
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}

      - name: Build and push backend
        uses: docker/build-push-action@3d5c3c13724e5350441b7e8b242807ddfdc8a67a
        with:
          context: .
          file: ./Dockerfile.backend
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push frontend
        uses: docker/build-push-action@3d5c3c13724e5350441b7e8b242807ddfdc8a67a
        with:
          context: .
          file: ./Dockerfile.frontend
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Deploy to Kubernetes
        uses: azure/k8s-deploy@v1
        with:
          manifests: |
            k8s/deployment.yaml
            k8s/service.yaml
            k8s/ingress.yaml
          images: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
```

### 9.4 监控与日志

#### 9.4.1 Prometheus配置

```yaml
# monitoring/prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "alert_rules.yml"

scrape_configs:
  - job_name: 'pytrading-backend'
    static_configs:
      - targets: ['backend:8000']
    metrics_path: '/metrics'
    scrape_interval: 5s

  - job_name: 'pytrading-mysql'
    static_configs:
      - targets: ['mysql-exporter:9104']

  - job_name: 'pytrading-redis'
    static_configs:
      - targets: ['redis-exporter:9121']

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093
```

#### 9.4.2 Grafana仪表盘

```json
{
  "dashboard": {
    "title": "xTrading系统监控",
    "panels": [
      {
        "title": "API请求量",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(http_requests_total[5m])",
            "legendFormat": "{{method}} {{endpoint}}"
          }
        ]
      },
      {
        "title": "API响应时间",
        "type": "graph",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))",
            "legendFormat": "95th percentile"
          }
        ]
      },
      {
        "title": "活跃WebSocket连接",
        "type": "stat",
        "targets": [
          {
            "expr": "websocket_connections_active"
          }
        ]
      },
      {
        "title": "回测任务队列长度",
        "type": "graph",
        "targets": [
          {
            "expr": "backtest_queue_length"
          }
        ]
      },
      {
        "title": "数据库连接数",
        "type": "graph",
        "targets": [
          {
            "expr": "mysql_global_status_threads_connected"
          }
        ]
      },
      {
        "title": "CPU使用率",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(container_cpu_usage_seconds_total[5m]) * 100",
            "legendFormat": "{{pod}}"
          }
        ]
      },
      {
        "title": "内存使用率",
        "type": "graph",
        "targets": [
          {
            "expr": "container_memory_usage_bytes / container_spec_memory_limit_bytes * 100",
            "legendFormat": "{{pod}}"
          }
        ]
      }
    ]
  }
}
```

#### 9.4.3 ELK日志聚合

```yaml
# logging/logstash.conf
input {
  beats {
    port => 5044
  }

  http {
    port => 8080
    codec => json
  }
}

filter {
  if [fields][service] == "pytrading-backend" {
    grok {
      match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{DATA:module} %{GREEDYDATA:msg}" }
    }

    date {
      match => [ "timestamp", "yyyy-MM-dd HH:mm:ss.SSS" ]
    }

    if [level] == "ERROR" {
      mutate {
        add_tag => [ "error" ]
      }
    }
  }

  if [fields][service] == "pytrading-frontend" {
    json {
      source => "message"
    }
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "pytrading-logs-%{+YYYY.MM.dd}"
  }

  if "error" in [tags] {
    http {
      url => "http://alertmanager:9093/api/v1/alerts"
      http_method => "post"
      format => "json"
      mapping => {
        "alerts" => [{
          "labels" => {
            "alertname" => "LogError"
            "service" => "%{[fields][service]}"
            "severity" => "warning"
          }
          "annotations" => {
            "summary" => "%{[msg]}"
          }
        }]
      }
    }
  }
}
```

---

## 10. 技术选型对比

### 10.1 后端框架对比

| 框架 | 性能 | 开发效率 | 生态 | 异步支持 | 学习成本 | 推荐指数 |
|------|------|----------|------|----------|----------|----------|
| FastAPI | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ✅ 推荐 |
| Django | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ❌ 不推荐 |
| Flask | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⚠️ 可选 |
| Tornado | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ | ❌ 不推荐 |

**选择理由：**
- ✅ **FastAPI**：高性能、自动API文档、类型提示、异步支持、现代化设计
- ❌ **Django**：过于重量级、性能相对较低、异步支持不够完善
- ⚠️ **Flask**：灵活但需要更多手动配置
- ❌ **Tornado**：学习曲线陡峭、生态较小

### 10.2 数据库选型对比

| 数据库 | 类型 | 性能 | 扩展性 | 事务支持 | 运维复杂度 | 适用场景 |
|--------|------|------|--------|----------|------------|----------|
| MySQL | 关系型 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ✅ 主数据库 |
| PostgreSQL | 关系型 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⚠️ 可选 |
| MongoDB | 文档型 | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ❌ 不推荐 |
| Redis | 缓存 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ✅ 缓存层 |
| InfluxDB | 时序 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ | ✅ 时序数据 |

**选择理由：**
- ✅ **MySQL**：成熟稳定、运维简单、生态丰富、事务支持完善
- ⚠️ **PostgreSQL**：功能更强大，但运维相对复杂
- ❌ **MongoDB**：不适合复杂查询、事务支持有限
- ✅ **Redis**：高性能缓存、支持多种数据结构
- ✅ **InfluxDB**：专业的时序数据库、适合行情数据

### 10.3 前端框架对比

| 框架 | 性能 | 开发效率 | 生态 | 学习成本 | 移动端支持 | 推荐指数 |
|------|------|----------|------|----------|------------|----------|
| React | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ✅ 推荐 |
| Vue.js | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⚠️ 可选 |
| Angular | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ | ❌ 不推荐 |
| Svelte | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⚠️ 可选 |

**选择理由：**
- ✅ **React**：生态成熟、组件化、TypeScript支持好、与React Native无缝集成
- ⚠️ **Vue.js**：学习曲线平缓、开发效率高，但移动端支持不如React
- ❌ **Angular**：过于重量级、学习成本高
- ⚠️ **Svelte**：性能优秀，但生态较小

### 10.4 图表库对比

| 库 | 性能 | 功能 | 易用性 | 定制性 | 移动端适配 | 推荐指数 |
|----|------|------|--------|--------|------------|----------|
| Recharts | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ✅ 推荐 |
| ECharts | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⚠️ 可选 |
| D3.js | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⚠️ 专业用户 |
| Chart.js | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⚠️ 可选 |

**选择理由：**
- ✅ **Recharts**：基于React、性能好、易用性强、专为React设计
- ⚠️ **ECharts**：功能最全面、定制性强，但集成稍复杂
- ⚠️ **D3.js**：最灵活、适合复杂可视化，但学习成本高
- ⚠️ **Chart.js**：简单轻量，但功能相对有限

### 10.5 消息队列对比

| 队列 | 性能 | 可靠性 | 运维难度 | 延迟 | 吞吐量 | 推荐指数 |
|------|------|--------|----------|------|--------|----------|
| RabbitMQ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ✅ 推荐 |
| Apache Kafka | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⚠️ 可选 |
| Redis Queue | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⚠️ 可选 |
| Amazon SQS | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ❌ 云服务限制 |

**选择理由：**
- ✅ **RabbitMQ**：功能完善、可靠性高、生态成熟、运维相对简单
- ⚠️ **Kafka**：性能极佳、吞吐量高，但运维复杂、学习成本高
- ⚠️ **Redis Queue**：简单易用、延迟低，但功能有限
- ❌ **SQS**：依赖云服务、成本不可控

### 10.6 容器编排对比

| 平台 | 易用性 | 功能 | 生态 | 运维成本 | 资源消耗 | 推荐指数 |
|------|--------|------|------|----------|----------|----------|
| Kubernetes | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ✅ 生产环境 |
| Docker Swarm | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⚠️ 小规模 |
| Docker Compose | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⚠️ 开发环境 |
| Nomad | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ❌ 小众 |

**选择策略：**
- ✅ **Kubernetes**：功能最全面、适合生产环境、但运维复杂
- ⚠️ **Docker Swarm**：简单易用、适合小规模应用
- ⚠️ **Docker Compose**：最适合开发环境、单主机部署
- ❌ **Nomad**：生态小、学习成本高

---

## 总结

### 架构优势

1. **微服务架构**：模块化设计、独立部署、易于扩展
2. **多平台支持**：桌面、Web、移动端统一体验
3. **高性能**：异步处理、缓存优化、并行计算
4. **高可用**：容器化部署、自动故障恢复、数据备份
5. **安全可靠**：JWT认证、RBAC权限、数据加密、审计日志
6. **开发效率**：代码生成、自动化测试、CI/CD流水线

### 技术亮点

1. **策略引擎模块化**：插件式架构、易于扩展
2. **实时数据流**：WebSocket推送、事件驱动
3. **智能缓存**：多层缓存、自动失效
4. **监控完善**：全链路监控、告警机制
5. **数据质量**：自动清洗、质量检查

### 适用场景

- **量化研究机构**：策略研发、回测分析
- **基金管理公司**：投资组合管理、风险控制
- **个人投资者**：量化交易、资产管理
- **金融机构**：算法交易、做市系统

### 未来规划

1. **AI增强**：机器学习策略、自动特征工程
2. **多市场扩展**：支持期货、期权、加密货币
3. **社区生态**：策略市场、开发者平台
4. **云原生升级**：Serverless架构、边缘计算

本设计文档基于现有项目架构进行了全面的优化和扩展，提供了完整的量化交易系统解决方案。通过微服务架构、容器化部署和现代化技术栈，系统具备了高性能、高可用、易扩展的特点，能够满足专业量化交易的需求。
